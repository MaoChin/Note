# `protobuf`初识

## 1. 序列化与反序列化

序列化：把对象转换为==字节序列==(二进制序列)的过程称为对象的序列化。

反序列化：把字节序列恢复为对象的过程称为对象的反序列化。  

需要序列化和反序列化的场景：

1. **数据存储，**一般需要将数据进行持久化存储或者存到缓存中都是需要序列化的。
2. **网络传输等**，网络传输中是不能直接传输对象的，都需要序列化成字节序列进行传输(TCP面向字节流)。

现有的序列化方案：`json`，`protobuf`，`xml`

## 2. `protobuf`认识

就是一种将结构化数据序列化的一种方案。==序列化的结果为**二进制字节序列**，而非文本格式。==  所以我们是看不懂的！而`json`序列化后我们是可以看懂的。

我们自己编写：

```C++
class test{
  // 属性字段
  // 处理字段的方法：set,get
  // 处理类的方法：序列化，反序列化
};
```

其中处理字段的方法和处理类的方法比较耗时---交给`protobuf`完成！！我们只需编写属性字段就可以了。

优点：

1. 语言无关，平台无关
2. 高效
3. 扩展性好，兼容性好

### 1. `protobuf`使用流程

1. 编写`.proto`文件，目的是为了定义结构对象（`message`）及属性内容。  
2. 使用`protoc`编译器编译`.proto`文件，生成一系列接口代码，存放在新生成头文件和源文件中。  
3. 依赖生成的接口，**将编译生成的头文件包含进我们的代码中**，实现对`.proto`文件中定义的字段进行设置和获取，和对message对象进行序列化和反序列化。  

总的来说：`protobuf`需要==依赖编译生成的头文件和源文件==来使用。

![image-20240112102921351](E:\Note\protobuf\protobuf初识.assets\image-20240112102921351.png)

### 2. 编写简单的`.proto`文件(使用`proto3`)

==`protobuf`是`Google`编写的，所以对命名，格式要求很规范！！==

文件名：文件命名应该使用全小写字母命名，多个字母之间用 _ 连接。例如：
`lower_snake_case.proto`。

注释：和C一样。  

`package`：可选的声明符，表示`.proto`文件的命名空间，所以要有==唯一性==。可以避免`message`命名冲突。(和C++的`namespace`差不多)

`message`：要定义的结构化对象，可以在这个结构化对象中定义其属性内容。使用驼峰命名法，首字母大写。  

```protobuf
// .proto文件样例
syntax = "proto3";    // 使用proto3版本，默认是proto2
package contacts;

// 定义message  驼峰命名
message PeopleInfo {
	// 字段类型 字段名 = 字段唯一编号;
  string name = 1;   
  int32 age = 2;
}
```

`.proto`文件编译后一个`message`就会对应一个类，然后对于每个字段会有对应的`set，get`方法，以及类的序列化，反序列化方法。

#### 1. `message`内字段

格式：**字段类型 字段名 = 字段唯一编号;**    

字段名称命名规范：全小写字母，多个字母之间用_连接。  

字段类型：标量数据类型+特殊类型(`enum，Any，oneof，map`)。下表是所有的标量数据类型。

| `.protoType ` | Notes                                                        | C++Type |
| ------------- | ------------------------------------------------------------ | ------- |
| double        | double                                                       | double  |
| float         | float                                                        | float   |
| int32         | 使用变长编码[1]。负数的编码效率较低⸺若字段可能为负值，应使用sint32代替。 | int32   |
| int64         | 使用变长编码[1]。负数的编码效率较低⸺若字段可能为负值，应使用sint64代替。 | int64   |
| uint32        | 使用变长编码[1]。                                            | uint32  |
| uint64        | 使用变长编码[1]。                                            | uint64  |
| sint32        | 使用变长编码[1]。符号整型。负值的编码效率高于常规的int32类型。 | int32   |
| sint64        | 使用变长编码[1]。符号整型。负值的编码效率高于常规的int64类型。 | int64   |
| fixed32       | 定长4字节。若值常⼤于2^28则会比uint32更高效。                | uint32  |
| fixed64       | 定长8字节。若值常⼤于2^56则会比uint64更高效。                | uint64  |
| sfixed32      | 定长4字节。                                                  | int32   |
| sfixed64      | 定长8字节。                                                  | int64   |
| bool          | bool                                                         | bool    |
| string        | 包含UTF-8和ASCII编码的字符串，长度不能超过 2^32。            | string  |
| bytes         | 可包含任意的字节序列但长度不能超过2^32。                     | string  |

[1] 变长编码是指：经过`protobuf`编码后，原本4字节或8字节的数可能会被变为其他字节数。比如变短(1字节/2字节)，使得传输/存储更高效。



字段唯一编号：用来标识字段，一旦开始使用就不能再改变。范围在1~536,870,911(2^29-1)，其中19000~19999不可用(预留的)。  

而且，范围为1~15的字段编号需要一个字节进行编码(字段编号也会序列化到结果中，这个字段编号占用1个字节)，16~2047内的数字需要两个字节进行编码。编码后的字节不仅只包含了编号，还包含了字段类型。所以==1~15要用来标记出现非常频繁的字段，要为将来有可能添加的、频繁出现的字段预留一些出来(序列化后体积更小，效率更高)。==

### 3. 编译过程

```shell
protoc [--proto_path=IMPORT_PATH] --cpp_out=OUT_DIR file.proto

protoc 是 Protocol Buffer 提供的命令行编译工具。
--proto_path 指定被编译的.proto文件所在目录，可多次指定，不指定就默认在当前目录下搜索。也可以使用 -I/...
--cpp_out=   指编译后的文件为 C++ ⽂件。
OUT_DIR      编译后生成文件的目标路径。
file.proto   要编译的.proto⽂件。
```

例如：

```shell
# 编译当前目录下的contacts.proto文件，生成C++文件也在当前目录下
protoc --cpp_out=./ contacts.proto
```

### 4. 编译后生成的文件

编译后会生成`xxx.pb.h`和`xxx.pb.cc`两个文件，主要包含以下信息：

1. 对于每个`message`生成对应的类。
2. 对`message`中每个字段操作的方法，如`get`和`set`。
3. 继承的序列化和反序列化方法。==序列化的结果为**二进制字节序列**，而非文本格式。==  

### 5. 使用编译后生成的文件进行序列化和反序列化







