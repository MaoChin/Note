# `Redis`典型应用

==`Redis`最常见的应用：缓存，存储数据(内存级数据库)，消息队列。==

## 1. 缓存(`Cache`)

缓存存在的本质：”==二八定律==“，即20%的数据可以应对80%的访问请求。

缓存是一个==相对==的概念。访问速度快的设备就可以作为访问速度慢的设备的缓存。基本是用`redis`来作为关系型数据库(如`MySQL`)的缓存。

关系型数据库相对于内存级数据库比较慢，提高性能的方法：

1. **开源**：引入`MySQL`集群。
2. **节流**：引入`redis`缓存，把访问请求转移到`redis`上，从而降低`MySQL`的访问量。

把热点数据存储在`redis`服务中，当访问请求(==”读“==)到来时，先查`redis`，若`redis`中没有，才访问`MySQL`。**”写“的请求还是要在`MySQL`中完成！**

### 1. 缓存中数据的更新策略

#### 1. 定期生成

把数据的访问量记录下来，然后**定期根据数据的访问量生成热点数据。**

这里根据访问日志计算分析出数据的访问量以及各种数据关系就是大数据工程师的日常工作！！ 

优点：简单可控。

缺点：实时性不好。对于突发的热点数据无法及时同步到缓存。

#### 2. 实时生成+缓存淘汰

就是**当访问没有缓存命中时就把这个数据同步到缓存中**。这样会导致缓存很容易就满了(用的是内存)！！所以需要缓存中数据淘汰的策略，把缓存中不是那么热点的数据删除掉！

==缓存淘汰策略(面试题)：==

1. **`FIFO(First In First Out)`**先进先出，先来的先淘汰。
2. **`LRU(Least Recently Used)`**淘汰最久未使用的，就是淘汰那些很久没有被访问的数据。
3. **`LFU(Least Frequently Used)`**淘汰访问次数最少的
4. **`Randam `** 随机淘汰，这个其实不合理！！

`Redis`可以通过配置文件设置使用哪种淘汰策略。

缓存淘汰策略和`key`的过期时间之间是相配合的，给`key`设置过期时间就是为了考虑其时效性，过期就将`key`删除了。

### 2. 缓存预热，缓存穿透，缓存雪崩，缓存击穿

#### 1. 缓存预热(`Cache preheating`)

在使用实时生成的 缓存数据更新策略时，当刚启动`redis`服务时由于其内部没有数据，所以大量的请求会直接访问`MySQL`服务，容易导致`MySQL`服务宕机！！所以==需要先加载部分数据到`redis`里，这叫做缓存预热。==

解决：在`redis`启动时加载定期生成的热点数据，将 定期生成 和 实时生成 相结合。

#### 2. 缓存穿透(`Cache penetration`)

==要访问的数据不在`MySQL`中，自然就不会在`redis`服务里，这样的访问也会去查询`MySQL`，相当于绕过了`redis`，直击`MySQL`，叫做缓存穿透。==当有大量这样的访问时就容易使`MySQL`服务宕机！

解决：

1. 对于`MySQL`中不存在的`key`也写入到`redis`中，`value`设置成非法值(如空串)就行。
2. 对要查询的参数做一些合法性检查，对不合法的查询直接忽略。
3. 在每次查询`MySQL`前先使用 布隆过滤器 判断一下`key`是否存在。

#### 3. 缓存雪崩(`Cache avalanche`)

==短时间内`redis`中的大量`key`失效/过期，导致`redis`服务中数据量非常少！！这时大量请求会访问到`MySQL`，导致`MySQL`宕机。==可能是由于`redis`服务宕机，也可能是短时间内大量的`key`过期

解决：

	1. 部署高可用的`redis`集群，防止`redis`服务宕机。
	1. 不要在短时间内给大量的`key`设置相近的过期时间。

#### 4. 缓存击穿/缓存瘫痪(`Cache breakdown`)

有点像缓存雪崩的特殊情况，特指==一些热点`key`过期==了，使得大量请求会访问到`MySQL`，导致`MySQL`宕机。

解决：

1. 使用统计的方法找到热点`key`，将其设置成永不过期。
2. 限制同时访问`MySQL`的并发数！！

## 2. 分布式锁

==在分布式系统中也会涉及到多个节点访问同一块公共资源的问题！！这时也要进行加锁，保护临界资源。==这里的锁就不能使用进程内的那个锁了，那个锁只能在同一个进程内起作用，而分布式系统是要在多个主机之间进行加锁！

这种分布式锁就可以使用`redis`来实现。

### 1. 基本概念

其实就是一个/一组单独的服务器程序，给其他的服务器提供加锁的服务---设置一个特殊的`key---value`。

**当有一个服务器访问临界资源时就尝试用`setnx`设置这个`key---value`，设置成功就表明加锁成功，可以访问；若这个`key---value`已经被设置过了，表示已经有服务器在访问临界资源了，那么这个服务器就设置失败，只能放弃或阻塞等待！**

`setnx`：当`key`不存在时才会设置成功！

### 2. 引入过期时间

若一个服务器程序加锁后宕机了，那这个锁就无法释放了！这时其他的服务器程序想访问临界资源就访问不了了！！所以==给锁加上过期时间，过期后就自动释放锁了(删除这个特殊的`key---value`)。==

`set nx ex` 这个命令就刚好可以设置过期时间。这里不要分开设置`key`和过期时间！！==就一条指令完成，保证原子性。==不然分开执行有可能设置过期时间的命令执行失败。

### 3. 引入校验`id`

还有问题：**一个服务器程序设置了`key---value`加锁后访问临界资源时 另一个服务器直接把这个`key`给删除了，就相当于释放了这个锁！！**

所以引入校验`id`，比如把`key---value`中的`value`设置成服务器的编号，在删除`key`时进行校验，看这个服务器是不是当初加锁的那个服务器。

### 4. 引入`lua`

上述校验过程是先查询(`get`)这个`key`的`value`，再删除(`del`)！！两步操作---不是原子的。

这就可能会有问题。这时一般就会使用`lua`脚本内嵌到`redis`来进行原子性的操作。(一个`lua`脚本的执行过程是原子的)

### 5. 引入`watch dog`

==`key`的过期时间设置问题：==

1. 设置的时间太长，那申请锁的服务器宕机时就会导致锁的释放不及时。
2. 设置的时间太短，则有可能服务器访问临界资源的业务还没完成就把锁给释放了！

这时就可以以==“动态续约”==的方式设置过期时间，把过期时间设置的短一点，然后定期检测业务是否完成，没完成就续约过期时间！！少量多次。而当服务器宕机后就不会续约了，就可以在较短的时间内释放锁。

**这个负责检测的线程就叫 `watch dog`。**

### 6. 引入 `Redlock` 算法

考虑分布式锁的服务是一个 主从+哨兵模式 的`redis`，这时若**主节点设置了某个`key---value` (针对某临界资源加了一个锁) 但还没来得及同步给从节点，然后主节点宕机了！！！**

这时哨兵节点会选举一个从节点上位为主节点，但是这个锁就没了！！！

`Redlock`算法就是解决这个问题的。简单的说就是引入==多组== 主从+哨兵 模式，但不是集群那种大家存不同的数据，而是每一组都存相同的数据。加锁时给所有组都设置 `key---value`。这样即使某个主节点挂了，也没啥影响！！

==核心思想：分布式系统中任何一个节点都是不可靠的，都有单点问题！！==

 
