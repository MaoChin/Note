# `Redis`通用命令 && 基本知识

## 通用命令

### 1. `keys`

进行模糊匹配。

```shell
keys pattern
```

### 2. `exists`

判断`key`是否存在。

```shell
exists key [key1 ...]
```

### 3. `del`

```shell
del key [key1 ...]
```

### 4. `expire`

给`key`添加秒级过期时间。

```shell
expire key 10  # 10s 后过期
```

`pexpire`是添加毫秒级过期时间。

### 5. `ttl`

查询`key`的过期时间。返回值：-1表示该`key`没有设置过期时间；-2表示该key不存在。

```shell
ttl key
```

`pttl`查询毫秒级过期时间。

### 6. `type`

查询`value`的类型。

```shell
type key
```

### 7. `flushall`

删除所有键值对！！就是删库！

```shell
flushall
```



## 基本知识

### 数据结构与内部编码

目前`Redis`的`value`有10种数据结构，常用的有5个：`string`，`list`，`hash`，`set`，`zset`。基本每种数据结构内部都有好几种内部编码实现(不一定是标准的实现方式)，这样一是为了**解耦**，上层使用和底层实现解耦，这样底层实现更新时不影响上层使用；二是每一种编码实现有其适用的场景，可以灵活选取。

![image-20230911201302926](E:\Note\Redis\Redis通用命令 && 基本知识.assets\image-20230911201302926.png)

查看`value`的内部编码：

```shell
object encoding key
```

### 单线程模式

只使用一个线程处理所有的命令请求，这就避免了并发问题。但不代表整个`Redis`只有一个线程！

现在`Redis`的**网络I/O处理是使用多线程的**。

==**单线程依然高效的原因：**==(和`MySQL`相比)

1. `Redis`的**数据都在内存中**。访问内存比访问硬盘快的多。
2. `Redis`在网络I/O中**使用`epoll`多路复用**，非常高效。
3. `Redis`的**核心业务逻辑都相对简单**，不怎么消耗CPU资源，所以即使是单线程也可以应付过来。并且搞多线程也提升不大。
4. 单线程**避免了并发访问带来的问题**，如线程间切换的消耗，多线程的互斥/同步操作...

但是也是由于单线程模式，对于某些==需要很长时间处理的操作==要特别小心，会导致这个线程一直在处理这一个操作，==使得其他的操作被阻塞！！==

### 字符编码

`redis`内部在**存储数据的时候是按照二进制的方式存储的**，不负责字符编码！！取出来的也是二进制码，要转换成汉字要客户端自己进行编码。

在启动`Redis`客户端时加上`--raw`就可以使其 尝试翻译二进制数据(转成汉字)。

```shell
redis-cli --raw
```

### 渐进式遍历

在使用 `keys *` 这类命令时有可能会一次获得大量的数据从而阻塞 `redis` 服务器！！！所以**这类命令一般禁止使用！！**

这时可以使用 `scan` 这类命令进行渐进式遍历 (O(1)) 代替上述的命令，既能获取所有的数据，又可以避免服务器被阻塞。

实现方式：不是一次把所有的数据全部拿到，而是一次获取一部分，通过多次调用 `scan` 获取所有的数据。 ==化整为零==

`scan/hscan/sscan/zscan` 用法差不多，后面几个是针对不同类型的。

`cursor`：光标，**不是下标**！！就是一个字符串，`redis`服务器知道这个光标对应的具体位置。第一次`scan`时`cursor`设成0，而后每一次`scan`会返回下一次的`cursor`值。

```shell 
# match：匹配规则-> ?表示匹配一个任意字符，*匹配任意多个字符......
# count：说明这一次scan获取多少个元素(仅仅是建议，不是强制)，默认是10
# type：指定value的类型
# 返回值：第一个是下一次scan的cursor值；后面是这一次获取的key
# 当返回的cursor是"0"时表示遍历结束。
scan cursor [match pattern] [count count] [type type]
```

`scan`遍历可以随时中断，不会影响服务器！！也就是说服务器不会保存遍历的任何中间状态。

==注意：如果在`scan`渐进式遍历的过程中键有所变化(比如新增/删除 键)，可能会导致遍历出的键 重复或丢失！！！==(就像C++里的迭代器失效)

### 多`database`

`redis`也是有多个`database`的。但是不能用户自己创建删除`database`，而是服务器提供了16个`database`(0~15号)，各个数据库之间是相互隔离的，对一个数据库的操作不会影响其他数据库 。默认我们使用0号数据库，并且==建议只使用这一个数据库，不建议在一个客户端使用多个。==

```shell
# 切换 database
select 0~15
# 获取当前database中key的个数
dbsize 
# 清空当前 database
flushdb
# 清空所有 database
flushall
```

