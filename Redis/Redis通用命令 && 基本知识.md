# `Redis`通用命令 && 基本知识

## 通用命令

### 1. `keys`

进行模糊匹配。

```shell
keys pattern
```

### 2. `exists`

判断`key`是否存在。

```shell
exists key [key1 ...]
```

### 3. `del`

```shell
del key [key1 ...]
```

### 4. `expire`

给`key`添加秒级过期时间。

```shell
expire key 10  # 10s 后过期
```

`pexpire`是添加毫秒级过期时间。

### 5. `ttl`

查询`key`的过期时间。返回值：-1表示该`key`没有设置过期时间；-2表示该key不存在。

```shell
ttl key
```

`pttl`查询毫秒级过期时间。

### 6. `type`

查询`value`的类型。

```shell
type key
```

### 7. `flushall`

删除所有键值对！！就是删库！

```shell
flushall
```



## 基本知识

### 数据结构与内部编码

目前`Redis`的`value`有10种数据结构，常用的有5个：`string`，`list`，`hash`，`set`，`zset`。基本每种数据结构内部都有好几种内部编码实现(不一定是标准的实现方式)，这样一是为了**解耦**，上层使用和底层实现解耦，这样底层实现更新时不影响上层使用；二是每一种编码实现有其适用的场景，可以灵活选取。

![image-20230911201302926](E:\Note\Redis\Redis通用命令 && 基本知识.assets\image-20230911201302926.png)

查看`value`的内部编码：

```shell
object encoding key
```

### 单线程模式

只使用一个线程处理所有的命令请求，这就避免了并发问题。但不代表整个`Redis`只有一个线程！

现在`Redis`的**网络I/O处理是使用多线程的**。

==**单线程依然高效的原因：**==(和`MySQL`相比)

1. `Redis`的**数据都在内存中**。访问内存比访问硬盘快的多。
2. `Redis`在网络I/O中**使用`epoll`多路复用**，非常高效。
3. `Redis`的**核心业务逻辑都相对简单**，不怎么消耗CPU资源，所以即使是单线程也可以应付过来。并且搞多线程也提升不大。
4. 单线程**避免了并发访问带来的问题**，如线程间切换的消耗，多线程的互斥/同步操作...

但是也是由于单线程模式，对于某些==需要很长时间处理的操作==要特别小心，会导致这个线程一直在处理这一个操作，==使得其他的操作被阻塞！！==













