# `Redis`事务(用的不多)

## 1. 事务简介

`MySQL`事务的四大特性：(ACID)

1. 原子性(`Atomicity`)

2. 一致性(`Consistency`)

3. 隔离性(`Isolation`)

4. 持久性(`Durability`)

   

==`Redis`的事务相比`MySQL`就要弱很多了：==

1. 原子性：`redis`可以做到把多个操作打包到一起，要么全都执行，要么全都不执行，但是**没有回滚机制，不保证操作结果的正确性！**

2. 一致性：**不保证一致性！！**

3. 隔离性 ：因为**`redis`是单线程处理请求的，所有的请求都是串行化执行的，**所以也没有隔离级别之说。

4. 持久性：本身**数据是保存在内存中的，没有持久性！！**但是提供了两种持久化机制。

   

==`redis`事务的意义：就是把多个操作打包 一起处理，避免在这多个操作中间有其他的操作插队执行！！==

## 2. 事务操作

`redis`实现事务借助一个事务队列，当开启事务时就会把用户的命令放到队列里，**并不会立即执行，而是等到`EXEC`命令后统一执行，这时这多个操作之间不会有其他的操作插入进来，**直到这些操作执行完，再处理其他的操作。

这样，这些操作要么全都执行，要么全都不执行(原子的)。

### 1. `multi`

开启一个事务。

```shell
multi
# 之后的set或者其他的操作都会放到事务队列里，不会立即执行！
```

### 2. `exec`

开始执行事务队列里的操作。

### 3. `discard`

放弃/销毁当前事务，同时把事务队列里的所有操作清空。

事务队列也是在内存中的，所以如果在`exec`之前重启`redis`服务也会导致事务被销毁。

### 4. `watch`

必须在`multi`之前开始监控。

有可能有这样一种情况：在客户端1中开启事务设置了`key`的值，然后在客户端2中有设置了`key`的值，最后才在客户端1`exec`执行事务队列里的操作。这时**客户端1先设置`key`的值但是会变成最终结果！！**

`watch`就是监控`key`的值，**看在事务之外(该事务有针对key的修改)有没有其他客户端改变了`key`的值，如果有，则在`exec`时就不会执行事务队列里的操作！！而是直接销毁事务。**(事务里的操作要么全都执行，要么全都不执行) 

`watch`实现是维护了要监控的`key`的版本号，每次有客户端修改`key`就会更新版本号，而后通过对比版本号来进行判断。

### 5. `unwatch`

取消对`key`的监控。







