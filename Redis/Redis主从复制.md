# `Redis`主从复制

之后的课程都是针对分布式的。主从复制，哨兵，集群......

实际生活中会遇到一个非常重要的问题：==单点问题==。就是服务器程序只部署在一个节点上，那么这个节点出现故障就凉凉了！！(**可用性低**)  而且单点**性能低，可支持的并发量小。**

分布式系统很大程度上就是为了解决单点问题：有多个服务器来部署`redis`服务，构成一个`redis`集群，用这个`redis`集群给其他模块提供更稳定，更高效的服务。

==分布式系统中都应该避免单点问题。==

`redis`部署模式：(这些都是`redis`自带的，没有打开关闭之说，进行配置即可)

1. 主从模式。从节点一般只读，是针对“读操作”的高可用和高并发。实际上也是“读”的操作远远大于“写”的操作。
2. 主从+哨兵模式
3. 集群模式

## 主从模式配置

主从模式中只能是主节点进行同步，写入时是先写到主节点，然后向从节点同步(==主->从==)。从节点是只读的(==可以修改，但是不建议==)。

另外，各个节点之间也是通过网络传输的！！网络是比磁盘还慢的外设！

### 1. 建立连接

配置主从节点：

1. 在配置文件中加入`slaveof masterHost masterPort`随Redis启动生效。
2. 在`redis-server`启动命令时加入`--slaveof masterHost masterPort`生效。
3. 启动后直接使用`redis`命令：`slaveof masterHost masterPort`生效。  

```shell 
# 方法2
redis-server /etc/redis/redis-slave.conf --port 6380 --slaveof 127.0.0.1 6379
```

启动`redis server`：

```shell 
# 搭配，当使用kill杀死redis-server时会自动重启(保证稳定性)
service redis-server start  
service redis-server stop

# 这样启动的redis-server 在kill后不会重启
redis-server /etc/redis/redis.conf
kill -9 pid
```

查看当前服务端的主从信息：

```shell
info replication  # 命令
```

### 2. 断开连接

```shell 
# 直接执行命令
slaveof no one
```

这样**这个从节点就是一个独立的主节点了！不会丢弃原来的数据。**但不会再从主节点同步数据。(==从节点这样可以晋升为主节点==)

也可以再次易主！！通过 `slaveof`命令再次做其他节点的从节点(临时的)。

### 3. 其他事项

1. 安全性
2. 网络传输延迟：主从节点也是通过网络建立连接传输数据的，这就势必会有网络传输延迟的问题。底层**`TCP`有`nagle`算法(增大延迟，节省带宽)**，可以通过配置项选择，默认关闭(`repl-disable-tcp-nodelay`)。

## 主从拓扑结构

就是很多个主从节点的连接方式。

### 1. 一主一从

![image-20230930215103052](E:\Note\Redis\Redis主从复制.assets\image-20230930215103052.png)

这时若写的压力过大可以关闭主节点的`AOF`持久化机制，只在从节点上进行持久化。但是这样要是主节点挂了不能重启！！**重启了会使得主节点数据丢失(主节点没有持久化)，进一步同步到从节点，从节点的数据也没了！！**主节点挂了要把从节点的备份文件给到主节点，然后重启。

### 2. 一主多从

![image-20230930215112820](E:\Note\Redis\Redis主从复制.assets\image-20230930215112820.png)

这时从节点太多时同步的压力会比较大。

### 3. 树型结构

![image-20230930215124265](E:\Note\Redis\Redis主从复制.assets\image-20230930215124265.png)

可以减少主节点的同步压力，分摊给他的一级从节点一些。但是同步的延时更长(有多层同步)！！

## 主从复制原理

### 1. 主从复制流程

![image-20231002154749725](E:\Note\Redis\Redis主从复制.assets\image-20231002154749725.png)

可以看到，前4步是建立连接和验证的准备阶段，第五步开始才真正的进行数据同步。

### 2. 数据同步

数据同步分为三方面：**全量复制，部分复制和实时复制。**都是从节点主动向主节点进行同步请求。

使用`psync`命令进行同步，这个同步是在建立了主从关系后自动同步的。主要有以下三个组件支持：==主从节点各自的复制偏移量，主节点复制积压缓冲区，`replicationid`。==

```shell
psync replicationid offset
```

![image-20231002164916658](E:\Note\Redis\Redis主从复制.assets\image-20231002164916658.png)

#### 1. `replication id` (`replid`)

![image-20231002160516561](E:\Note\Redis\Redis主从复制.assets\image-20231002160516561.png)

可以看到，这里有两个`master_replid`，一个是真正的运行`id`，另一个是备用的，在哨兵模式中从节点也可能会晋升为主节点，这时这个`id2`就用来保存之前旧的那个主节点`id`。

从节点的 `replication id` 也是 `master_replid`，和它的主节点是一样的，是这一个主从模型的统一的`id`。

#### 2. `offset`偏移(描述进度)

主从节点都会维护一个偏移量，主节点的偏移量是他自己操作数据的进度，从节点的偏移量则是其同步的进度。主节点也会有从节点同步的进度。

**`replication id`和`offset`共同描述了一个数据集合。**

#### 3. 积压缓冲区(`repl_backlog`)

是指当出现网络抖动等情况使得某个从节点与主节点断开连接(只是一小会)，这时**主节点的相关操作会暂时存到积压缓冲区中**，等到再次建立连接时就根据偏移等数据只需进行部分复制，而无需进行全量复制。

#### 4. 全量复制

一般**首次进行主从连接的时候进行，会将主节点的所有数据同步到从节点**，但是效率比较低。

#### 5. 部分复制

当进行全量复制后可能会因为网络抖动而导致主节点重启再次连接从节点，这时只需要将这短时间修改的那部分数据进行同步即可。效率更高。

具体判断：==先看`replication id`，==看之前是不是在同一个主从复制模型里，==是的话在看`offset`偏移==，看从节点落下的同步数据是不是在积压缓冲区内，是的话就会触发部分复制。否则依然是全量复制。

#### 6. 实时复制

就是主从关系已经建立并且已经进行过全量复制后，随着时间的推移，从节点把主节点的操作实时的复制过来。

#### 7. `replication id` 和 `runid` 的区别

`runid`是每一个节点都有的，而且各不相同，用于标识每一个节点。在哨兵模式中会用到这个`runid`。

`replication id` 用于标识一个主从模型，**在同一个主从模型中的所有节点有相同的`replication id` **，而`replication id`不同则说明不在同一个主从模型里。在主从复制中一般用的都是这个 `replication id` 。

### 3. 心跳包

当主从连接建立后，他们之间需要维护长连接来进行实时复制。这是就用到心跳包来维护长连接。

主节点默认每隔10秒对从节点发送`ping`命令，判断从节点的存活性和连接状态。

从节点默认每隔1秒向主节点发送`replconf ack {offset}`命令，给主节点上报自身当前的复制偏移量。  

## 主从复制未解决的问题

1. 从节点太多时，复制数据的延迟很长。
2. 当主节点挂了，从节点不能自动升级成主节点(==从节点主动和主节点断开连接时从节点是可以升级成主节点的，但是主节点挂了，那就不行了==)，需要人工干预。(哨兵机制解决)
3. 主节点可以将“读”的压力分担出去，但是“写”和存储 的压力无法被分担。通过集群的方式解决。
