# `Redis`主从复制

之后的课程都是针对分布式的。主从复制，哨兵，集群......

实际生活中会遇到一个非常重要的问题：==单点问题==。就是服务器程序只部署在一个节点上，那么这个节点出现故障就凉凉了！！(**可用性低**)  而且单点**性能低，可支持的并发量小。**

分布式系统很大程度上就是为了解决单点问题：有多个服务器来部署`redis`服务，构成一个`redis`集群，用这个`redis`集群给其他模块提供更稳定，更高效的服务。

`redis`部署模式：

1. 主从模式。从节点一般只读，是针对“读操作”的高可用和高并发。实际上也是“读”的操作远远大于“写”的操作。
2. 主从+哨兵模式
3. 集群模式

## 主从模式配置

主从模式中只能是主节点进行同步，写入时是先写到主节点，然后向从节点同步(==主->从==)。从节点是只读的(==可以修改，但是不建议==)。

### 1. 建立连接

配置主从节点：

1. 在配置文件中加入`slaveof masterHost masterPort`随Redis启动生效。
2. 在`redis-server`启动命令时加入`--slaveof masterHost masterPort`生效。
3. 启动后直接使用`redis`命令：`slaveof masterHost masterPort`生效。  

```shell 
# 方法2
redis-server /etc/redis/redis-slave.conf --port 6380 --slaveof 127.0.0.1 6379
```

启动`redis server`：

```shell 
# 搭配，当使用kill杀死redis-server时会自动重启(保证稳定性)
service redis-server start  
service redis-server stop

# 这样启动的redis-server 在kill后不会重启
redis-server /etc/redis/redis.conf
kill -9 pid
```

查看当前服务端的主从信息：

```shell
info replication  # 命令
```

### 2. 断开连接

```shell 
# 直接执行命令
slaveof no one
```

这样**这个从节点就是一个独立的主节点了！不会丢弃原来的数据。**但不会再从主节点同步数据。

也可以再次易主！！通过 `slaveof`命令再次做其他节点的从节点(临时的)。

### 3. 其他事项

1. 安全性
2. 网络传输延迟：主从节点也是通过网络建立连接传输数据的，这就势必会有网络传输延迟的问题。底层**`TCP`有`nagle`算法(增大延迟，节省带宽)**，可以通过配置项选择，默认关闭(`repl-disable-tcp-nodelay`)。

## 主从拓扑结构

就是很多个主从节点的连接方式。

### 1. 一主一从

![image-20230930215103052](E:\Note\Redis\Redis主从复制.assets\image-20230930215103052.png)

这时若写的压力过大可以关闭主节点的`AOF`持久化机制，只在从节点上进行持久化。但是这样要是主节点挂了不能重启！！**重启了会使得主节点数据丢失(主节点没有持久化)，进一步同步到从节点，从节点的数据也没了！！**主节点挂了要把从节点的备份文件给到主节点，然后重启。

### 2. 一主多从

![image-20230930215112820](E:\Note\Redis\Redis主从复制.assets\image-20230930215112820.png)

这时从节点太多时同步的压力会比较大。

### 3. 树型结构

![image-20230930215124265](E:\Note\Redis\Redis主从复制.assets\image-20230930215124265.png)

可以减少主节点的同步压力，分摊给他的一级从节点一些。但是同步的延时更长(有多层同步)！！

## 主从复制原理

