# `C++`模板(泛型编程)

时刻牢记编译时，链接时，运行时！！还有静态和动态的区别！！

## 1. 理解泛型编程

泛型编程就是编写==与类型无关的通用型代码==，是代码复用的一种手段，`C++`中模板是实现泛型编程的一种手段。

## 2. 函数模板

```C++
# typename 也可以用 class 代替
template<typename T>
void Swap(T& left, T& right)
{
  T temp = left;
  left = right;
  right = temp;
}
```

### 1. 函数模板的理解

函数模板本身不是函数，就是一个模板。==在编译器编译阶段，会根据传入的实参类型推导生成对应类型的函数==。也就是说，模板就是把我们要干的活交给了编译器！让编译器去生成对应类型的函数。（**编译时动态生成的**)

### 2. 函数模板的实例化

模板的实例化就是==编译器根据实参类型推导对应类型函数的过程==。

![image-20231101173634078](E:\Note\C++\C++模板.assets\image-20231101173634078.png)

#### 1. 隐式实例化

就是编译器根据实参自动推导。

#### 2. 显式实例化

显式指定模板参数类型。

```C++
template<typename T>
void Swap(T& left, T& right)
{
  T temp = left;
  left = right;
  right = temp;
}
int main()
{
  int a = 1;
  double d = 3.3;
  // 显式指定
  Swap<int>(a, d);
  return 0;
}
```

### 3. 函数模板的匹配规则

如果**有显式实现的参数类型最匹配的函数，那就优先匹配显式实现的函数**，编译器不会再生成对应类型的函数。否则编译器才会生成对应类型的函数。

## 3. 类模板

```C++
template<class T1, class T2, ..., class Tn>
class 类名
{
	// 类内成员定义
};
```

==类模板必须显式的指定模板参数类型==，因为这个编译器无法自动推导！

```C++
// vector只是类名，vector<int>才是类型
vector<int> s1;
vector<double> s2;
```

## 4. 非类型模板参数

模板参数分为==类型模板参数和非类型模板参数==。类型模板参数就是普通的在 `class/typename`后面的参数，由调用方指定参数类型，也可以给缺省值。而==非类型模板参数就是用一个常量作为参数==，



## 5. 模板特化与偏特化





## 6. 模板分离编译的问题

一个程序是由很多源文件共同编译实现的，在编译时每个源文件都会生成一个目标文件，然后由链接器链接所有的目标文件生成可执行文件，这个过程称为分离编译！

但是模板分离编译会有问题！(就是在 `xxx.h` 文件中声明一个模板，然后在`xxx.cc`中定义该模板，在==另外一个 `xxx.cc`文件中使用模板==)

![image-20231102190352996](E:\Note\C++\C++模板.assets\image-20231102190352996.png)

会有链接错误！！**在模板定义的文件中不知道模板参数的具体类型**，所以不会实例化出真正可以调用的函数，符号表中也就没有函数地址！！所以在链接时找不到对应的函数地址。

模板分离编译问题的解决：

1. ==不要把 模板的定义 和 使用模板的函数 分到不同的文件中分开编译！==
2. 在模板定义的文件中显式的指定模板参数类型。



