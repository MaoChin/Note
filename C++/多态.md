# 多态

牢记有虚函数的类就有虚表指针，**虚表的本质是函数指针数组。**

## 1. 多态的基本知识

### 1. 基本概念

==多态就是对同一件事，当不同的对象去执行时会有不同的结果，造成不同的状态。==比如买票，不同的人买票的结果是不同的---学生半价，军人优先.......再比如一些社交软件，不同的会员有不同的待遇等等。

### 2. 构成多态的必要条件

1. **==必须是父类的指针或引用调用虚函数。==**
2. **==子类必须重写父类的虚函数。==**

### 3. 虚函数

虚函数就是类中用 `virtual`修饰的函数。

```C++
// 虚函数示例
class A
{
public:
  // 虚函数
  virtual void Print()
  {
    // ...
  }
  // ...
};
```

#### 虚函数覆盖

也叫==虚函数重写==，是指**派生类中的虚函数和基类中对应的虚函数完全一样：包括返回值，函数名和参数列表都一样！！**但是具体的实现一般不一样，这样就构成了多态的原型---不同的对象调用同一个函数有不同的结果。

派生类重写的虚函数可以不用 `virtual`修饰，但是基类的虚函数必须用 `virtual`修饰。建议都加上！！

#### 虚函数覆盖的两个例外

1. 协变：是指基类虚函数返回某个基类对象的**指针或者引用**，派生类虚函数返回对应的派生类对象的指针或者引用。这样虽然返回值不同，但是也构成虚函数覆盖。

   ```C++
   // 协变示例
   class A{};
   class B : public A {};
   class Person 
   {
   public:
     virtual A* f() {return new A;}
   };
   class Student : public Person 
   {
   public:
     virtual B* f() {return new B;}
   }
   ```

2. 析构函数的覆盖：只要基类的析构函数用`virtual`修饰(也建议这么做)，那么派生类的析构函数就会自动构成覆盖！！这里可以认为编译器将析构函数名做了处理，统一将析构函数名命名为 `destructor`。

### 4. 重载，隐藏与覆盖

函数重载是指在==同一个作用域==中可以定义同名函数，只要参数列表不同即可。

隐藏也叫重定义，是指父类和子类(==两个作用域==)有相同的成员函数/成员变量名(只要名称一样就构成隐藏)。

覆盖也叫重写，是指父类和子类(==两个作用域==)有相同的虚函数(返回值，函数名，参数列表都一样)！

![image-20231118100404136](E:\Note\C++\多态.assets\image-20231118100404136.png)

### 5. `override` 和 `final`

C++11的两个关键字，用于强制检查。

`final`关键字==修饰基类虚函数==，表示该虚函数不能被派生类覆盖，否则报错！

`override`关键字==修饰派生类虚函数==，表示该虚函数必须是覆盖了基类的虚函数，否则报错！

## 2. 抽象类

==抽象类==是指包含了纯虚函数的类，也叫做==接口类==。抽象类==不能实例化出对象==，而且派生类继承抽象类后也不能实例化出对象，==只有重写纯虚函数，派生类才能实例化出对象。==

这样抽象类就规范了派生类必须重写纯虚函数！这是一种强制==接口继承！==

```C++
// 抽象类示例
class A
{
public:
  virtual void Print() = 0;  // 纯虚函数  后面加 =0
}
```

### 1. 接口继承与实现继承

普通函数的继承是一种**实现继承**，派生类继承了基类函数，可以使用函数，**继承的是函数的实现**。虚函数的继承是一种接口继承，**派生类继承的是基类虚函数的接口，目的是为了重写，构成多态**，继承的是接口。所以如果不实现多态，不要把函数定义成虚函数。  

接口继承---派生类虚函数返回值，参数也都是继承的基类的，包括==函数参数的缺省值==也是基类的！！！

![image-20231118120211334](E:\Note\C++\多态.assets\image-20231118120211334.png)

## 3. 多态的底层原理---虚表指针

### 1. 虚表指针(虚函数表指针)

类中只要有虚函数，其成员里就有一个虚函数表指针，简称虚表指针。指向虚函数表，**虚函数表又是一个函数指针数组**，数组里每一个成员是一个函数指针，指向虚函数的实现(虚函数表里没有一般成员函数的指针)。数组的最后一个元素是 `nullptr`。

==虚表指针在类对象中存储(`sizeof(类对象)`时别忘了这个指针)，而虚函数表在VS下存在代码段，虚函数和普通成员函数一样，也在代码段。==

基类的虚表直接生成。而派生类的虚表则是先将基类中的虚表内容拷贝一份到派生类虚表中，如果派生类重写了基类中某个虚函数，就用派生类自己的虚函数覆盖虚表中基类的虚函数(==覆盖的是指针，虚表本质是函数指针数组==)，然后将派生类自己新增加的虚函数(如果有的话)按其在派生类中的声明次序增加到派生类虚表的最后(增加的是指针)。

```C++
// 观察虚表
class Base
{
public:
	virtual void Func1()
  {
  	cout << "Base::Func1()" << endl;
  }
  virtual void Func2()
  {
  	cout << "Base::Func2()" << endl;
  }
  void Func3()
  {
  	cout << "Base::Func3()" << endl;
  }
private:
  int _b = 1;
};
class Derive : public Base
{
public:
  virtual void Func1()
  {
  	cout << "Derive::Func1()" << endl;
  }
private:
  int _d = 2;
};
```

在VS下观察上述代码的`Base`类和`Derive`类对象：

![image-20231118104018210](E:\Note\C++\多态.assets\image-20231118104018210.png)

## 4. 多继承中的虚表指针











