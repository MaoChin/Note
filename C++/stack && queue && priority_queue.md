# `stack` && `queue` && `priority_queue`

这三个要遍历只能访问一遍其中的元素，因而这三个容器适配器==没有提供迭代器！==

## 1. `stack`(后进先出)

### 1. 常用接口

| 函数说明   | 接口说明                  |
| ---------- | ------------------------- |
| `stack() ` | 构造空的栈                |
| `empty() ` | 检测`stack`是否为空       |
| `size() `  | 返回`stack`中元素的个数   |
| `top() `   | 返回栈顶元素的引用        |
| `push() `  | 将元素`val`压入`stack`中  |
| `pop() `   | 将`stack`中尾部的元素弹出 |

## 2. `queue`(先进先出)

### 1. 常用接口

| 函数声明   | 接口说明                                        |
| ---------- | ----------------------------------------------- |
| `queue() ` | 构造空的队列                                    |
| `empty() ` | 检测队列是否为空，是返回`true`，否则返回`false` |
| `size() `  | 返回队列中有效元素的个数                        |
| `front() ` | 返回队头元素的引用                              |
| `back() `  | 返回队尾元素的引用                              |
| `push() `  | 在队尾将元素`val`入队列                         |
| `pop() `   | 将队头元素出队列                                |

## 3. `priority_queue` (堆)

### 1. 基本介绍

`priority_queue`就是一个堆，并且**默认是大堆(`less`)。**这里和正常的排序逻辑是反的，正常来说，`greater(>)` 是降序，应该是大堆；`less(<)`是升序，应该是小堆！！而这里==`less(<)`是大堆==！算是一个`bug`。

`greater`和`less`都是标准库里的仿函数(`functional`)。

### 2. 常用接口

| 函数声明                                        | 接口说明                                           |
| ----------------------------------------------- | -------------------------------------------------- |
| `priority_queue()/priority_queue(first, last) ` | 构造一个空的优先级队列                             |
| `empty()`                                       | 检测优先级队列是否为空，是返回true，否则返回 false |
| `top()`                                         | 返回优先级队列中最大(最小元素)，即堆顶元素         |
| `push(x) `                                      | 在优先级队列中插入元素x                            |
| `pop() `                                        | 删除优先级队列中最大(最小)元素，即堆顶元素         |

## 4. 适配器模式 

适配器的作用就是==转换==：底层是另外一个容器/迭代器，经过适配器转换后得到一个其他的容器/迭代器。并且 底层的那个容器/迭代器 可以自己指定，只要符合接口规则即可。

### 1. 容器适配器

以上三个严格来说并不是容器，而是==容器适配器，其底层封装了其他的容器==，对用户来说是隐藏的。我们只是通过接口使用而已！

实际上，`stack`和`queue`底层默认使用的是`deque`(可改)，`priority_queue`底层默认使用的是`vector` (可改)。但是**`queue`的底层不要使用`vector`**，因为`vector`头删效率低；**`priority_queue`的底层容器的迭代器要是随机访问迭代器**，因为建堆，向上调整，向下调整等等需要能随机访问。

![image-20231113115806908](E:\Note\C++\stack && queue && priority_queue.assets\image-20231113115806908.png)

`priority_queue`的第三个模板参数是一个仿函数，==用仿函数控制大堆小堆==！这是==泛型编程==的一个典型应用。

### 2. 迭代器适配器

==反向迭代器就是适配了正向迭代器得到的！==

### 3. `deque`简单介绍

“双开口”的存储空间“连续”的数据结构！“双开口”表示其==可以O(1)的头插头删，尾插尾删！==并且存储空间可以认为是连续的：`deque`==并不是真正连续的空间，而是由一段段连续的小空间拼接而成的。==

`deque`底层是一段假想的连续空间，实际是分段连续的，为了维护其“整体连续”以及随机访问的假象，就由`deque`的迭代器实现，因此`deque`的迭代器设计就比较复杂，  

![image-20231113214932231](E:\Note\C++\stack && queue && priority_queue.assets\image-20231113214932231.png)

`deque`优点：一是==头插头删，尾插尾删效率高==，并且扩容效率也不差(比`vector`好)。二是存储空间“连续”，==空间利用率高==。

`deque`缺点：一是==不适合遍历==，因为在遍历时，`deque`的迭代器要频繁的去检测其是否移动到某段小空间的边界，导致效率低下。二是==中间位置的插入删除效率低==！ 

**而`stack`和`queue`刚好只在头尾操作数据，不会在中间位置插入删除，也没有提供迭代器进行遍历！所以选择`deque`作为他们的底层容器再适合不过了。**











