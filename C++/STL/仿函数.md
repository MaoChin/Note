# 仿函数

仿函数在很大程度上是为了**替代函数指针。**仿函数配合`lambda`表达式爽到飞起！

## 1. 基本概念

仿函数本质是一个自定义类型(`struct/class`)；然而在类中重载了 () 运算符！这样这个==类对象就可以像函数调用那样使用了==---仿函数。

```C++
// 一个简单的仿函数(添加了模板)
// 一般而言，这个类中不需要其他的成员函数和成员变量，就是把他当作函数调用使用
template<class T>
struct less
{
  bool operator()(const T& x, const T& y) const	
  {
    // 若T是自定义类型，那么该自定义类型需要重载 < 运算符
    return x < y;
  }
};

int main()
{
  // 用类实例化一个对象 compare
  less<int> compareless;
  // 因为类内重载了() ，所以可以像函数调用那样使用
  // 但是本质是调用了operator() :  compare.operator(1, 2);
  cout << compareless(1, 2) << endl;
  return 0;
}
```

这样仿函数这个类类型就可以当作==模板参数==传到其他的类中，这样避免了函数指针的使用，毕竟函数指针非常复杂！这是一种典型的==泛型编程==。当然也可以先用类实例化出对象，然后**把对象(仿函数)当作参数传递**，最终目的是一样的。

并且针对不同的规则可以定义==多个类==，每个类中都重载 () ，然后根据需求选择特定的仿函数。

这里的泛型思想是通过模板参数达到对==逻辑==的控制！之前学的是通过模板参数达到对==类型==的控制。
