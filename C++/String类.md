# `string`类

## 1. 编码简介

有很多不同的编码规范，如：`ASCII`，`UTF-8`，`UTF-16`，`UTF-32`，`GBK`......

根据**编码的不同**，有不同的`string`类！！不同的`string`类底层的字符类型是不同的，这就做到了一层抽象封装！

·![image-20231102204555201](E:\Note\C++\String类.assets\image-20231102204555201.png)

## 2. `string`常用接口

### 1. 默认成员函数

#### 1. 构造/拷贝构造

![image-20231103210330211](E:\Note\C++\String类.assets\image-20231103210330211.png)

#### 2. 赋值重载

![image-20231103210523007](E:\Note\C++\String类.assets\image-20231103210523007.png)

### 2. 容量操作函数

| 函数名称          | 功能说明                                                     |
| ----------------- | ------------------------------------------------------------ |
| `size`（重点）    | 返回字符串==有效字符==长度                                   |
| `length `         | 返回字符串有效字符长度                                       |
| `capacity `       | 返回空间总大小                                               |
| `empty` (重点）   | 检测字符串是否为空串，是返回true，否则返回false              |
| `clear` (重点）   | 清空有效字符，==空间还在！==                                 |
| `reserve` (重点） | 为字符串预留空间，仅扩容，==不改变有效字符个数。==           |
| `resize` (重点）  | 将有效字符的个数改成n个，多出的空间用字符c填充，默认用'\0'填充。扩容+初始化，==改变有效字符个数!== |

### 3. 访问及遍历操作

| 函数名称             | 功能说明                                                     |
| -------------------- | ------------------------------------------------------------ |
| `operator[]` （重点) | 返回pos位置的字符                                            |
| `begin`，`end `      | begin获取第一个字符的迭代器，end获取最后一个字符下一个位置的迭代器。==前闭后开== |
| `rbegin`，` rend `   | 反向迭代器                                                   |
| 范围 `for `          | C++11支持的更简洁的范围for遍历方式，底层就是迭代器！         |

==迭代器有正向/反向，`const`/非`const`的区分。==

### 4. 修改操作

| 函数名称              | 功能说明                                                   |
| --------------------- | ---------------------------------------------------------- |
| `push_back`           | 在字符串后尾插字符c                                        |
| `append `             | 在字符串后追加一个字符串                                   |
| `operator+=` (重点)   | 在字符串后追加字符串str                                    |
| `c_str`(重点)         | 返回C格式字符串，配合C语言                                 |
| `find` + `npos`(重点) | 从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置 |
| `rfind `              | 从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置 |
| `substr `             | 在str中从pos位置开始，截取n个字符，然后将其返回            |
| `insert`              | 在str中特定的位置插入字符/字符串，涉及到挪动数据           |
| `erase`               | 删除str中特定位置的字符/字符串，也涉及到挪动数据           |
| `swap`                | 交换两个 `string` 类，交换指针                             |

### 5. 非成员函数

| 函数                            | 功能说明                                 |
| ------------------------------- | ---------------------------------------- |
| `operator+ `                    | 尽量少用，因为传值返回，导致深拷贝效率低 |
| `operator>> `（重点）           | 输入运算符重载                           |
| `operator<<` （重点）           | 输出运算符重载                           |
| `getline` （重点）              | ==获取一行字符串，包括空格。==           |
| `relational operators` （重点） | 大小比较                                 |

## 3. `npos`

`string`类的一个静态成员变量：

```C++
# 就是 42亿多，可以代表无限大
static const size_t npos = -1;
```

## 4. `VS`系列和`g++`中`string`类的结构

### 1. `VS`系列



### 2. `g++`



## 5. `string`类的模拟实现

### 1. 深浅拷贝

==当类成员变量有在堆上动态开辟空间存值时，拷贝构造就必须要是自己写的深拷贝！！==编译器生成的那个默认拷贝构造就不行了！会有内存问题---**两个对象中的成员变量指向了同一块堆空间！！**

1. 其中一个对象对其作了改变会影响另一个。
2. **两个对象销毁时都会调用析构函数，释放两次同一块空间**，就会报错！！

![image-20231016171607020](E:\Note\C++\string类.assets\image-20231016171607020.png)

**所以当类中有维护动态开辟的空间时，其==拷贝构造，赋值重载，析构==都要自己显示的实现，并且要以==深拷贝==的形式实现。**

### 2. 拷贝构造和赋值重载的现代写法

#### 1. 一般写法

```C++
class String
{
public:
	// ...
  // 拷贝构造
  String(const String& s)
  	: _str(new char[strlen(s._str) + 1])
  {
  	strcpy(_str, s._str);
  }
  // 赋值重载
  String& operator=(const String& s)
  {
    // 先开空间
    char* pStr = new char[strlen(s._str) + 1]; // \0
    strcpy(pStr, s._str);
    delete[] _str;
    _str = pStr;
  }
  // ...
};
```

#### 2. 现代写法

```C++
class String
{
public:
	// ...
  // 拷贝构造
  String(const String& s)
  	: _str(new char[strlen(s._str) + 1])
  {
  	strcpy(_str, s._str);
  }
  // 赋值重载
  String& operator=(const String& s)
  {
    // 先开空间
    char* pStr = new char[strlen(s._str) + 1]; // \0
    strcpy(pStr, s._str);
    delete[] _str;
    _str = pStr;
  }
  // ...
};
```

## 3. 写时拷贝和引用计数

















