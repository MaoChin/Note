# `string`类

## 1. 编码简介

有很多不同的编码规范，如：`ASCII`，`UTF-8`，`UTF-16`，`UTF-32`，`GBK`......

根据**编码的不同**，有不同的`string`类！！不同的`string`类底层的字符类型是不同的，这就做到了一层抽象封装！

·![image-20231102204555201](E:\Note\C++\String类.assets\image-20231102204555201.png)

## 2. `string`常用接口

### 1. 默认成员函数

#### 1. 构造/拷贝构造

![image-20231103210330211](E:\Note\C++\String类.assets\image-20231103210330211.png)

#### 2. 赋值重载

![image-20231103210523007](E:\Note\C++\String类.assets\image-20231103210523007.png)

### 2. 容量操作函数

| 函数名称          | 功能说明                                                     |
| ----------------- | ------------------------------------------------------------ |
| `size`（重点）    | 返回字符串==有效字符==长度                                   |
| `length `         | 返回字符串有效字符长度                                       |
| `capacity `       | 返回空间总大小                                               |
| `empty` (重点）   | 检测字符串是否为空串，是返回true，否则返回false              |
| `clear` (重点）   | 清空有效字符，==空间还在！==                                 |
| `reserve` (重点） | 为字符串预留空间，仅扩容，==不改变有效字符个数。==           |
| `resize` (重点）  | 将有效字符的个数改成n个，多出的空间用字符c填充，默认用'\0'填充。扩容+初始化，==改变有效字符个数!== |

### 3. 访问及遍历操作

| 函数名称             | 功能说明                                                     |
| -------------------- | ------------------------------------------------------------ |
| `operator[]` （重点) | 返回pos位置的字符                                            |
| `begin`，`end `      | begin获取第一个字符的迭代器，end获取最后一个字符下一个位置的迭代器。==前闭后开== |
| `rbegin`，` rend `   | 反向迭代器                                                   |
| 范围 `for `          | C++11支持的更简洁的范围for遍历方式，底层就是迭代器！         |

==迭代器有正向/反向，`const`/非`const`的区分。==

### 4. 增删查改

| 函数名称              | 功能说明                                                   |
| --------------------- | ---------------------------------------------------------- |
| `push_back`           | 在字符串后尾插字符c                                        |
| `append `             | 在字符串后追加一个字符串                                   |
| `operator+=` (重点)   | 在字符串后追加字符串str                                    |
| `c_str`(重点)         | 返回C格式字符串，配合C语言                                 |
| `find` + `npos`(重点) | 从字符串pos位置开始往后找字符c，返回该字符在字符串中的位置 |
| `rfind `              | 从字符串pos位置开始往前找字符c，返回该字符在字符串中的位置 |
| `substr `             | 在str中从pos位置开始，截取n个字符，然后将其返回            |
| `insert`              | 在str中特定的位置插入字符/字符串，涉及到挪动数据           |
| `erase`               | 删除str中特定位置的字符/字符串，也涉及到挪动数据           |
| `swap`                | 交换两个 `string` 类，交换指针                             |

### 5. 非成员函数

| 函数                            | 功能说明                                 |
| ------------------------------- | ---------------------------------------- |
| `operator+ `                    | 尽量少用，因为传值返回，导致深拷贝效率低 |
| `operator>> `（重点）           | 输入运算符重载                           |
| `operator<<` （重点）           | 输出运算符重载                           |
| `getline` （重点）              | ==获取一行字符串，包括空格。==           |
| `relational operators` （重点） | 大小比较                                 |

### 6. 其他常用函数

字符串转整型：`stoi`

整型转字符串：`to_string`

## 3. `npos`

`string`类的一个静态成员变量：

```C++
# 就是 42亿多，可以代表无限大
static const size_t npos = -1;
```



## 4. `string`类的模拟实现

### 1. 深浅拷贝

==当类成员变量有在堆上动态开辟空间存值时，拷贝构造就必须要是自己写的深拷贝！！==编译器生成的那个默认拷贝构造就不行了！会有内存问题---**两个对象中的成员变量指向了同一块堆空间！！**

1. 其中一个对象对其作了改变会影响另一个。
2. **两个对象销毁时都会调用析构函数，释放两次同一块空间**，就会报错！！

![image-20231016171607020](E:\Note\C++\string类.assets\image-20231016171607020.png)

**所以当类中有维护动态开辟的空间时，其==拷贝构造，赋值重载，析构==都要自己显示的实现，并且要以==深拷贝==的形式实现。**

### 2. 拷贝构造和赋值重载的现代写法

#### 1. 一般写法

```C++
class String
{
public:
	// ...
  // 拷贝构造
  String(const String& s)
  	: _str(new char[strlen(s._str) + 1])
  {
  	strcpy(_str, s._str);
  }
  // 赋值重载
  String& operator=(const String& s)
  {
    if(this != &s)
    {
      // 先开空间
      char* pStr = new char[strlen(s._str) + 1]; // \0
      strcpy(pStr, s._str);
      delete[] _str;
      _str = pStr;
    }
		return *this;
  }
  // ...
};
```

#### 2. 现代写法(==重点==)

思想就是不自己开空间，而是去复用构造/拷贝构造完成，自己只`swap`一下就行了。

```C++
class String
{
public:
	// ...
  // 拷贝构造
  String(const String& s)
  	: _str(nullptr)
  {
    // 复用构造函数
    string strTmp(s._str);
  	swap(_str, strTmp._str);
  }
  // 赋值重载，这里不传引用了，直接传值，完成了拷贝构造
  String& operator=(String s)
  {
		swap(_str, s._str);
    return *this;
    // 出了函数作用域后对象销毁会自动调用析构函数把s._str的空间释放掉。
  }
  // ...
};
```

### 3. 迭代器

`string`的迭代器就是原生指针。

```C++
class string
{
public:
  typedef char* iterator;
  typedef const char* const_iterator;
  // ...

private:
  char* str_;
  size_t size_;
  size_t capacity_;
  
  const static size_t npos;
};
const size_t string::npos = -1;
```

## 5. 写时拷贝和引用计数(了解)

进行深拷贝时先不拷贝，而是进行浅拷贝，但是==维护一个变量记录有几个对象指向我这块空间---引用计数==！当一个对象销毁时看引用计数是不是1，==是1才真正把这块空间释放掉==，否则就把引用计数减1，而不释放空间。简单来说就是最后一个析构的对象才真正释放资源。

但是这样会有线程安全问题，就是多个对象指向了同一块资源！其中一个改变了这块资源其他的对象都会跟着改变。此时可以写时拷贝，==当某一个对象那个要写资源时再给这个对象进行深拷贝。==



