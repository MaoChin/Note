# 类和对象(重点)

## 1. 理解面向对象

==管理：先描述，再组织。==

面向过程：**关注**的是**过程**，分析出求解问题的步骤，通过函数调用逐步解决问题。 

面向对象：关注的是**对象**，将一件事情拆分成不同的对象，**靠对象之间的交互完成**。

### 1. 理解封装

**封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。  **

在C++语言中实现封装，可以**通过类将数据以及操作数据的方法进行有机结合，通过访问权限来隐藏对象内部实现细节，控制哪些方法可以在类外部直接被使用**。  

==C语言数据和方法分离，太过自由！！==而封装就是一种更强的管理机制，限制自由。

## 2. 类的基础知识

一般在 `.h`文件中定义类，类中的方法/函数 只进行声明，在 `.cpp` 文件中对类内的方法/函数进行实现。(==声明和定义分离==)

当然，也可以在类内定以函数，这时该函数可能会被当成内联函数，所以在类内定义的函数应当短小，逻辑简单。

### 1. 类访问限定符

1. `private`
2. `protected` (继承多态中使用)
3. `public`

### 2. 类作用域

一个类内是一个新的作用域。

### 3. 类实例化

==用 类类型 创建对象的过程，称为类的实例化。==

类仅仅是对对象的描述/声明，并没有真正的分配内存空间。而实例化创建对象就是申请内存空间，存储对象，也就是定义。

==存储规则：==

1. ==成员函数存储在公共的代码段==，大家公用！**(节省空间)**
2. 类对象的大小只是成员变量的大小！(**内存对齐**)
3. 空类也会占一个字节大小(取决于编译器)，标识其存在。

## 3. `this`指针

==`this`指针是非静态成员函数隐藏的形参，由编译器维护。指向 调用者 这个实例化出的对象。==

1. `this`指针的类型：==`类类型* const this`==，`const`修饰`this`本身，表示该指针只能指向该对象，不能修改，但是指向的对象可以修改。
2. `this`指针**本质上是“成员函数”的形参**，当对象调用成员函数时，将对象地址作为实参传递给`this`形参。所以对象中不存储`this`指针。  
3. `this`指针是“成员函数” 第一个 隐含的指针形参，一般情况由编译器通过`ecx`寄存器自动传递，不需要用户传递。

![image-20231015200340804](E:\Note\C++\类和对象.assets\image-20231015200340804.png)

4. 给`this`指针加 `const`

```C++
class Test
{
  // 后面那个const是给this指针的，此时是： const Test* const this
  void Print(int a) const
  {
    // ...
  }
};
```

5. `this`指针是函数形参，一般存在栈中。但也有可能存储在寄存器中，看编译器。

## 4. 类的六个默认成员函数

### 1. 构造函数

构造函数是一个特殊的成员函数，==名字与类名相同==，创建 类类型对象 时由编译器自动调用，以保证每个数据成员都有 一个合适的初始值，并且在对象整个生命周期内只调用一次。

==构造函数的主要任务并不是开空间创建对象，而是初始化对象。==

1. 构造函数**函数名和类名相同。**

2. 构造函数**没有返回值。**

3. 在**类实例化对象时**编译器会**自动调用构造函数初始化该对象。**

4. 构造函数**可以重载。**

5. 无参的构造函数和全缺省的构造函数都称为默认构造函数，并且**默认构造函数只能有一个，也有可能没有**。注意：**==无参的构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数==，都可以认为是默认构造函数**。也就是说==构造函数和默认构造函数是不一样的！！！==

6. 如果类中**没有显式定义构造函数**，则C++编译器会自动生成一个无参数的默认构造函数，一旦用户显式定义编译器将不再生成。 **默认生成的构造函数对内置类型不做处理，对自定义类型会调用它的==默认==构造函数。**


简单来说：默认构造函数就是==不传参数就可以初始化对象。==

如果一个类没有默认构造函数，就是**自己写了构造函数，但是该构造函数不是无参数的构造函数也不是全缺省的构造函数**，那么这个类在实例化的时候就必须要传相对应的参数！！不然会报错。(==推荐 类内都要有默认构造函数==)

### 2. 析构函数

清理对象中的资源，==不是对 对象本身 的销毁，而是清理对象中的资源，比如堆空间的释放。==在对象销毁的时候会自动调用析构函数。

1. 析构函数名：**`~类名`**
2. 析构函数**没有参数也没有返回值。**
3. **一个类中只能有一个析构函数**，不能重载，如果不显示定义，系统会自动生产默认的析构函数。
4. 系统自动生成的析构函数对内置类型不做处理，对自定义类型会调用它的析构函数。
5. 如果类中没有申请资源时(如堆空间)，析构函数可以不写，直接使用编译器生成的默认析构函数就可以，但是**类中有申请资源时必须自己显式的写析构函数释放资源，不然会造成内存泄漏！！**
6. 在**对象的生命周期结束时会系统会自动调用析构函数**清理对象中的资源。

同一个作用域中多个对象的析构顺序：后进先出！**最后构造的对象最先析构**。==(栈帧)==

### 3. 拷贝构造(C++规定对象之间的拷贝必须调用拷贝构造函数)

拷贝构造函数：只有单个形参，==该形参是对本类类型对象 的引用(一般用const修饰)，在用已存在的 类类型对象 创建新对象时由编译器自动调用。==

1. 拷贝构造函数本质就是**构造函数的一个重载。**
2. 拷贝构造函数的**参数有且仅有一个**且**必须是 类类型对象 的引用**，且建议用`const`修饰。使用**传值方式编译阶段会报错**，因为会引发无穷递归调用。
3. 如果没有显式定义，编译器会自动生成默认的拷贝构造函数。 默认的拷贝构造函数对内置类型**按内存存储按字节序完成拷贝(`memcopy`)，这种拷贝叫做浅拷贝，或者值拷贝。**对自定义类型调用它的拷贝构造函数。

为什么拷贝构造函数的参数必须是 类类型对象 的**引用**：因为如果使用传值传参，在传参数的时候就要把==实参拷贝给形参==，而==拷贝构造函数形参类型就是类类型本身，拷贝的时候就要调用该类的拷贝构造函数！！！==调用拷贝构造函数就要传参，传参又要调用拷贝构造.......所以就会引发无穷递归调用！使用引用传参就可以避免这个问题。 

#### 深浅拷贝问题：

==当类成员变量有在堆上动态开辟空间存值时，拷贝构造就必须要是自己写的深拷贝！！==编译器生成的那个默认拷贝构造就不行了！会有内存问题---**两个对象中的成员变量指向了同一块堆空间！！**

1. 其中一个对象对其作了改变会影响另一个。
2. **两个对象销毁时都会调用析构函数，释放两次同一块空间**，就会报错！！

![image-20231016171607020](E:\Note\C++\类和对象.assets\image-20231016171607020.png)

### 4. 赋值重载

#### 1. 运算符重载

C++为了增强代码的可读性引入了运算符重载函数，==运算符重载函数就是具有特殊函数名的函数，目的就是为了使自定义类型也能正常的使用各种运算符！==

这个重载和 函数重载没有任何关系！！这里的意思是 ==针对不同的自定义类型重新定义各个运算符的意义！==

运算符重载后 类类型 就可以正常使用该运算符了！编译器会自动解析成对应的函数	调用！

```C++
// 参数个数由 操作数 决定
// 函数原型：返回值类型 operator操作符(参数列表)
bool operator==(const Date& d1, const Date& d2)
{
  // 针对 Date 类型重新定义 == 运算符的意义！！方便使用
  // ...
}

int main()
{
  Date d1;
  Date d2;
  // 用的时候直接这样写！编译器会解析成函数调用：operator==(d1, d2)
  if(d1 == d2)
  {
    // ...
  }
}
```

1. **`operator`后只能跟运算符。**
2.  运算符重载函数必须要有 类类型 的参数(针对不同的自定义类型重新定义各个运算符的意义)。
3. 运算符重载函数可以是全局的函数，也可以是==类内的成员函数(更推荐)==。
4.  运算符重载函数 作为类内 成员函数 重载时，其形参看起来比操作数数目少1，因为成员函数的第一个参数为隐藏的`this`指针。
5. 有5个运算符不能重载：**`.  .*  ::  sizeof  ?:` (`sizeof`是运算符！)**

#### 2. 赋值运算符重载

==就是一个特殊的运算符重载，重载的是赋值运算符！==

```C++
// 参数：const T&  引用减少传值消耗，并且用 const 修饰
// 返回值：有返回值是为了支持连续赋值！ T& 返回引用减少消耗，
class Date
{
public:
  // ...
  Date& operator=(const Date& d)
  {
    // 检测一下是否是自己给自己赋值！提高效率 
    if(this != &d)
    {
      year_ = d.year_;
      month_ = d.month_;
      day_ = d.day_;
    }	
    // 有返回值是为了支持连续赋值！
    return *this; // this 就是指向对象的指针，就好像 i=j 会返回 i
  }
private:
  int year_;
  int month_;
  int day_;
};
```

1. 用户没有显式实现赋值重载时，编译器会生成一个默认赋值运算符重载函数，对内置类型**按内存存储按字节序完成拷贝(`memcopy`)，也就是浅拷贝。**
2. ==赋值运算符只能重载成类的成员函数不能重载成全局函数。==因为赋值运算符如果不显式实现，编译器会生成一个默认的。此时用户再在类外自己实现一个全局的赋值运算符重载，就和编译器在类中生成的默认赋值运算符重载冲突了。



**赋值运算符重载也有深浅拷贝问题：**和拷贝构造那里一样，当类成员变量有在堆上动态开辟空间存值时，编译器默认生成的赋值重载函数会导致多个对象中的成员变量指向同一块堆空间！！

1. 其中一个对象对其作了改变会影响另一个。
2. **两个对象销毁时都会调用析构函数，释放两次同一块空间**，就会报错！！

![image-20231016220148277](E:\Note\C++\类和对象.assets\image-20231016220148277.png)

这时要自己写赋值重载进行深拷贝！

### 5. 普通对象取地址重载

### 6. `const`对象取地址重载









