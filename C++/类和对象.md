# 类和对象(重点)

## 1. 理解面向对象

==管理：先描述，再组织。==

面向过程：**关注**的是**过程**，分析出求解问题的步骤，通过函数调用逐步解决问题。 

面向对象：关注的是**对象**，将一件事情拆分成不同的对象，**靠对象之间的交互完成**。

### 1. 理解封装

**封装：将数据和操作数据的方法进行有机结合，隐藏对象的属性和实现细节，仅对外公开接口来和对象进行交互。  **

在C++语言中实现封装，可以**通过类将数据以及操作数据的方法进行有机结合，通过访问权限来隐藏对象内部实现细节，控制哪些方法可以在类外部直接被使用**。  

==C语言数据和方法分离，太过自由！！==而封装就是一种更强的管理机制，限制自由。

## 2. 类的基础知识

一般在 `.h`文件中定义类，类中的方法/函数 只进行声明，在 `.cpp` 文件中对类内的方法/函数进行实现。(==声明和定义分离==)

当然，也可以在类内定以函数，这时该函数可能会被当成内联函数，所以在类内定义的函数应当短小，逻辑简单。

### 1. 类访问限定符

1. `private`
2. `protected` (继承多态中使用)
3. `public`

### 2. 类作用域

一个类内是一个新的作用域。

### 3. 类实例化

==用 类类型 创建对象的过程，称为类的实例化。==

类仅仅是对对象的描述/声明，并没有真正的分配内存空间。而实例化创建对象就是申请内存空间，存储对象，也就是定义。

==存储规则：==

1. ==成员函数存储在公共的代码段==，大家公用！**(节省空间)**
2. 类对象的大小只是成员变量的大小！(**内存对齐**)
3. 空类也会占一个字节大小(取决于编译器)，标识其存在。

## 3. `this`指针

==`this`指针是成员函数隐藏的形参，由编译器维护。指向调用者这个实例化出的对象。==

1. `this`指针的类型：==`类类型* const this`==，`const`修饰`this`本身，表示该指针只能指向该对象，不能修改，但是指向的对象可以修改。
2. `this`指针**本质上是“成员函数”的形参**，当对象调用成员函数时，将对象地址作为实参传递给`this`形参。所以对象中不存储`this`指针。  
3. `this`指针是“成员函数” 第一个 隐含的指针形参，一般情况由编译器通过`ecx`寄存器自动传递，不需要用户传递。

![image-20231015200340804](E:\Note\C++\类和对象.assets\image-20231015200340804.png)

4. 给`this`指针加 `const`

```C++
class Test
{
  // 后面那个const是给this指针的，此时是： const Test* const this
  void Print(int a) const
  {
    // ...
  }
};
```

5. `this`指针是函数形参，一般存在栈中。但也有可能存储在寄存器中，看编译器。

## 4. 类的六个默认成员函数

### 1. 构造函数

构造函数是一个特殊的成员函数，==名字与类名相同==，创建 类类型对象 时由编译器自动调用，以保证每个数据成员都有 一个合适的初始值，并且在对象整个生命周期内只调用一次。

==构造函数的主要任务并不是开空间创建对象，而是初始化对象。==

1. 构造函数**函数名和类名相同。**

2. 构造函数**没有返回值。**

3. 在**类实例化对象时**编译器会**自动调用构造函数初始化该对象。**

4. 构造函数**可以重载。**

5. 无参的构造函数和全缺省的构造函数都称为默认构造函数，并且**默认构造函数只能有一个**。注意：**==无参的构造函数、全缺省构造函数、我们没写编译器默认生成的构造函数==，都可以认为是默认构造函数**。也就是说==构造函数和默认构造函数是不一样的！！！==

6. 如果类中**没有显式定义构造函数**，则C++编译器会自动生成一个无参数的默认构造函数，一旦用户显式定义编译器将不再生成。 **默认生成的构造函数对内置类型不做处理，对自定义类型会调用它的==默认==构造函数。**

   

如果一个类没有默认构造函数，就是**自己写了构造函数，但是该构造函数不是无参数的构造函数也不是全缺省的构造函数**，那么这个类在实例化的时候就必须要传相对应的参数！！不然会报错。

### 2. 析构函数

### 3. 拷贝构造

### 4. 复制重载

### 5. 普通对象取地址重载

### 6. `const`对象取地址重载









