# `RabbitMQ`特性（一）

### 1. 确认应答

这里确认应答主要分为两个部分，一是`broker`对于生产者的确认应答，二是消费者对于`broker`的确认应答。其中`broker`对于生产者的确认应答在工作模式的`Publisher Confirms`中讲到。而消费者对于`broker`的确认应答机制其实也差不多，**都和`TCP`的确认应答非常像。**

##### 消费者的确认应答机制

消费者对于`broker`的确认应答机制大体上分为两类：

一是==自动确认==，即只要消费者消费了消息就会触发自动确认，`broker`就会将对应的消息删除掉，无论消费者是否真的正常收到了消息。这种方式可靠性低。

二是==手动确认==，即消费者消费消息后需要手动调用`basicAck`方法通知`broker`消费者确实收到了消息，然后`broker`再做后续的处理。此时`broker`中的消息会分为两部分：

![image-20241211165033420](E:\Note\RabbitMQ\RabbitMQ特性（一）.assets\image-20241211165033420.png)

手动确认的三个方法：

1. 肯定确认：`Channel.basicAck(long deliveryTag, boolean multiple) `
2. 否定确认：`Channel.basicReject(long deliveryTag, boolean requeue)`   
3. 否定确认：`Channel.basicNack(long deliveryTag, boolean multiple, boolean requeue)`  

 其中 `requeue` 表示`broker`是否把该消息再放到队列中，以便发送给后续的消费者；第二个否定确认函数只能拒绝一条消息，而第三个则可以通过`multiple`参数拒绝多条消息。

`deliveryTag`：是每个`Channel`独立维护的，所以在每个通道上都是唯一的，它确保了消息传递的可靠性和顺序性。

### 2. 消息持久化机制

主要是针对`broker`（即`RabbitMQ Server`）对于消息的持久化处理，防止断电重启等情况导致的消息丢失。

主要是三个部分的持久化：

1. `Exchange` 的持久化
2. `Queue`的持久化
3. 消息的持久化

其中，由于消息是存储在`Queue`里的，所以要想使消息持久化，必须要使`Queue`持久化。

消息的持久化势必会造成性能上的损失，因为要将相关消息内容写到磁盘上。

上述持久化并不能确保消息完全持久化到磁盘，因为`RabbitMQ`并不会为每条消息都进行同步存盘（调用内核的`fsync`方法），可能仅仅保存到操作系统缓存之中而不是物理磁盘之中，然后定期刷盘提高效率。此时服务器宕机就会导致持久化失败！！问题解决：

冲裁队列。（其实就是集群处理）

### 3. 生产者的确认应答

见工作模式中的`Publisher Confirms`模式。

上述三点特性其实就是为了保证`RabbitMQ`的可靠传输。

![image-20241212095409668](E:\Note\RabbitMQ\RabbitMQ特性（一）.assets\image-20241212095409668.png)

1. 生产者到交换机之间：`Publisher Confirms`模式的`confirm`方式。
2. 交换机到队列之间：`Publisher Confirms`模式的`return`方式。
3. `broker`内部：持久化机制。
4. 队列到消费者之间：确认应答机制。

### 4. 重传机制

**主要是`broker`给消费者的重传。**且这个重传机制只会在 消费者的确认应答机制 为==自动确认==时才生效。

自动确认模式下，程序逻辑异常，会按照配置进行重新发送，直到达到配置的重试次数。此时消息的`deliveryTag`不变。

### 5. `TTL(Time To Live)`

就是过期时间，`RabbitMQ`可以针对队列（影响队列中的所有消息）和每一条消息设置过期时间，若队列和队列中的消息都设置了过期时间，则消息的过期时间取最小值。

##### 队列中已经过期的消息的移除

1. 若是针对队列设置的`TTL`，那么队列中已过期的消息肯定在队列头部，所以`RabbitMQ`只要定期从队头开始扫描是否有过期的消息，有的话直接删除即可。
2.  若是针对消息设置的`TTL`，删除所有过期消息需要扫描整个队列，非常耗时，所以采用懒汉模式，当消息被消费时检查`TTL`，如果已经过期就删除掉，当然也会检查队头的消息。

### 6. `Dead Message`

当消息出现一下几种情况时就会变成死信（`dead message`）:

1. 消息被消费者拒绝（ `Basic.Reject/Basic.Nack` )，并且设置 `requeue` 参数为`false`，无法重新回到队列。
2. 消息过期（`TTL`到了）
3. 队列已经满了，此时生产者再发送消息就会变成`dead message`。

当消息在一个队列中变成死信之后，它能被重新被发送到另一个交换器中，这个交换器就是`DLX( Dead Letter Exchange)`，绑定`DLX`的队列，就称为死信队列`(Dead Letter Queue)`，简称DLQ。  

![image-20241212102059464](E:\Note\RabbitMQ\RabbitMQ特性（一）.assets\image-20241212102059464.png)

死信的作用：

1. 作为日志，辅助分析异常情况。
2. 消息保存与重试。

### 7. 延迟队列

延迟队列`(Delayed Queue)`，即消息被发送以后，并不想让消费者立刻拿到消息，而是等待特定时间后，消费者才能拿到这个消息进行消费。

`RabbitMQ`本身没有直接实现延迟队列的的功能，但是可以通过上述==`TTL `+ 死信队列==的方式组合模拟实现出延迟队列的功能。    

![image-20241212102621440](E:\Note\RabbitMQ\RabbitMQ特性（一）.assets\image-20241212102621440.png)

但是如果队列中不同消息的`TTL`不同，就会导致已经到期的消息（不再队头）不会按时进入死信队列！！所以针对不同过期时间的消息需要放到不同的`Queue`中，或者使用官方提供的延迟队列插件。 

### 8. 事务

`RabbitMQ`事务允许开发者确保消息的发送和接收是原子的，即一批消息要么全部发送成功，要么全部失败。  

### 9. 消息分发

消费者消费`broker`中的消息有两种模式：

1. “推”：即`broker`把消息推给消费者
2. “拉”：即消费者主动从`broker`中拉取数据。

消息分发机制主要用于“推”模式下，有计划的给消费者推送消息，可以防止推送太快使消费者来不及处理。

消息分发机制的作用：

1. 限流，控制发送给消费者的请求数量。
2. 负载均衡，防止同一个队列的 多个消费者之间忙闲不均。





