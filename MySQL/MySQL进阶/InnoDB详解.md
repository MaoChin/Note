# `InnoDB`详解

## 1. `InnoDB`简介

`InnoDB`在设计时考虑到了处理巨大数据量时的性能，`InnoDB`支持==事务==(`transaction`)、==回滚==(`rollback`)并且具有==崩溃修复==的能力(`crash recovery capabilities`)，通过==多版本并发控制==(`multi-versioned concurrency control`)减少锁定，同时还支持==外键约束==(`FOREIGN KEY constraints`)，通过==缓冲池==在主内存中缓存数据从而提高查询性能，也可以每个表使用各自的独立表空间存储数据并且文件大小只受限于操作系统，由于`InnoDB`存储引擎**存储数据量大，性能高，可以有效的保证数据安全**等优点，在MySQL5.5版本之后成为默认的存储引擎。  

`InnoDB`架构（主要包括**内存结构**（效率）和**磁盘结构**（安全，持久化）：

![image-20240628222817312](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240628222817312.png)

## 2. `MySQL`存储结构

#### 表空间

`MySQL`使用不同存储引擎创建表时生成的表空间数据文件，这里主要介绍使用`InnoDB`存储引擎创建表时生成的表空间数据文件。  

表空间文件是用来存储表中数据的文件，表空间文件的大小由存储的数据多少决定，不同的表空间文件存储数据的种类也有所不同，在`MySQL`中表空间分为五类，包括：**系统表空间、独立表空间、通用表空间、临时表空间和撤销表空间**，这些在上面的`InnoDB`架构图中都有体现。  

#### 表空间的组成

表空间由段(`segment`)、区组(`group`)、区(`extent`)、页(`page`)、数据行组成，其中==页是`InnoDB`磁盘管理的最小单位==，即页是内存和磁盘交互的基本单位。  

![image-20240629104249422](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240629104249422.png)

#### 局部性原理

时间局部性（`Temporal Locality`）：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。

空间局部性（`Spatial Locality`）：将来要用到的信息大概率与正在使用的信息在空间地址上是临近的。  

#### 页

通常操作系统中的文件系统在管理磁盘文件时以4KB大小为一个管理单元，称为"数据块"，但是在数据库的应用场景里，查询时数据量都比较大，如果也使用4KB做数据存储的最小的单元，就显的有点小了，同时会造成频繁的磁盘I/O，导致降低效率；所以`MySQL`根据自身情况定义了大小为16KB的页（可以自定义更改），做为磁盘管理的最小单位。（==减少磁盘I/O，提高性能==）

 每次内存与磁盘的交互至少读取一页，所以在磁盘中每个页内部的地址都是连续的，之所以这样做，是因为在使用数据的过程中，根据局部性原理，将来要使用的数据大概率与当前访问的数据在空间上是临近的，所以一次从磁盘中读取一页的数据放入内存中，当下次查询的数据还在这个页中时就可以从内存中直接读取，从而减少磁盘I/O，提高性能。     

#### 区

磁盘随机访问非常低效，所以要尽可能使页在磁盘上连续，减少磁头，盘面的移动以提升效率。为了保证存储数据的**页在磁盘上连续**，引入区的概念。

`MySQL`使用`Extent`(区)这个结构来管理页，规定每个区固定带下为 1MB ，可以存放 64 个连续的页，这时如果跨页读数据时，大概率都在附近的地址，可以大幅减少磁头移动。

![image-20240629112730394](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240629112730394.png)

## 3. 页结构

`InnoDB`在不同的使用场景定义多种不同类型的页，常用的有数据页、 `Undo Log`页 、`Change Buffer`页 、 `Extent Descriptor(XDES)`页 、 `InnoDB`段信息页等，每种页的数据结构都不相同，其中最需要我们关注的就是**数据页**，由于`InnoDB`中有个概念叫"索引即数据"，所以也叫做**索引页**。  

#### 页头和页尾

不论哪种类型的页都具有页头(`File Header`)和页尾(`File Trailer`)两个信息。  

![image-20240629145537342](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240629145537342.png)

LSN：是"`Log Sequence Number`"的缩写，表示日志序号。用一个任意的、不断增加的值表示日志中记录的操作对应的时间点，用8字节的无符号长整形表示。与 `Redo Log`相关。

#### 页主体

一个页中除了页头和页尾，还有页主体：页主体中的信息都是和数据相关的，其中包括==数据行==（存储真正的数据，与表里的数据行一一对应），还有为了提高查询效率的==页目录==`Page Directory` 和为了方便操作和管理数据页的==数据页头== `Page Header`。  

#### 数据行

数据行**主要存储真实数据**，为了方便数据的管理与描述，`InnoDB`在每个数据行中还添加了一些额外(管理)信息，于是每一个 `DYNAMIC` 数据行都可以划分为两部分，一部分存储额外信息，一部分存储真实数据，额外信息部分包含 变长字段长度列表 和 NULL值列表 两个大小不确定的区域，以及固定占5字节（40bit）的头信息区域，头信息中存储了行的基本信息，包括行在页内的位置 `heap_no` 、行类型 `record_type` 、下一行的地址偏移量`next_record` 等6项信息。  

![image-20240629152721606](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240629152721606.png)

标识新页中的第一行和最后一行：最小行/最大行：

![image-20240629154313992](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240629154313992.png)

#### 页目录

提高一页内查询数据行的效率。总体是二分查找的思想。

注意==索引的粒度是页==！！==通过索引可以快速找到数据在哪一个页==！！而这个页目录是在页内找数据行！！

#### 数据页头

存储事务，索引信息，位置信息等，方便操作和管理数据页。

#### 总的页结构

![image-20240629164447383](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240629164447383.png)

## 4. 行结构

就是**页结构中数据行的细节信息**。（==属性 + 内容==）

#### 数据行格式分类

1. `REDUNDANT` 冗余格式
2. `COMPACT` 紧凑格式
3. `DYNAMIC` 动态格式
4. `COMPRESSED` 压缩格式

其中默认是 `DYNAMIC` 格式。

#### `DYNAMIC`数据行格式

![image-20240710092644984](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240710092644984.png)

`DB-TX-ID` 和 `DB-ROLL-PTR`  用于事务。 

#### 额外信息（属性）中的内容

头信息：

![image-20240710093905670](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240710093905670.png)

空值列表：标识可以为NULL的列是否真的为NULL（节省空间）

![image-20240710095321319](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240710095321319.png)

变长字段长度列表：记录变长字段具体的长度

![image-20240710104041711](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240710104041711.png)

## 5. `InnoDB`内存结构（==提高效率==）

1. `Buffer Pool` 缓冲池  
2. `Change Buffer` 变更缓冲区  
3. `Adaptive Hash Index` 自适应哈希索引
4. `Log Buffer` 日志缓冲区

![image-20240710170002456](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240710170002456.png)

#### `Buffer Pool` 缓冲池（提高整体效率）

和磁盘中分段分区分页类似，也是逐层划分的（==分治==）。内存中的`Page`和磁盘中的`Page`是一一对应的。

![image-20240710112919947](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240710112919947.png)

但是在`Page`在内存中没有办法建立关联关系（在磁盘中是通过页头中的 页号*16KB 的偏移量来表示的），所以引入了新的结构--“控制块”：

![image-20240710114019228](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240710114019228.png)

内存中`Page`的管理：

1. `Free List` ：只管理`Free`页（开辟空间未使用的页）
2. `LRU List` ：管理`Clean`页（已使用但未修改的页）和`Dirty`页（使用并且修改的页）
3. `Flush List` ：只管理`Dirty`页（进行落盘）

#### `Change Buffer` 变更缓冲区（提高修改数据时的效率）

变更缓冲区用来缓存对**二级索引**数据的修改，当数据页没有被加载到内存中时先把修改缓存起来，等到其他查询操作发生时数据页被加载到内存后，再直接修改内存中的数据页，从而达到减少磁盘I/O的目的。  

简单来说就是把多个修改操作缓存到`Change Buffer`中，当对应的数据加载到`Buffer Pool`时再修改，减少磁盘`I/O`！！

![image-20240710163549817](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240710163549817.png)

#### `Adaptive Hash Index` 自适应哈希索引（提高查询效率）

根据`InnoDB`内部的监控机制，如果监控到某些==查询==通过建立哈希索引可以提高性能，则自动对这个页创建哈希索引，这个过程称为自适应，所以叫自适应哈希索引。

#### `Log Buffer` 日志缓冲区

在对数据库进行`DML`操作时，`InnoDB`会记录对应操作的日志，比如为保证数据完整性实现数据库崩溃恢复的 `Redo Log`，这些日志会首先写入`Log Buffer`中，从而解决同步写磁盘导致的性能问题，然后根据不同落盘策略最终写入磁盘。      

## 6. `InnoDB`磁盘文件（==保存数据==）

`InnoDB`的磁盘文件主要是表空间文件和其他文件，表空间包括：系统表空间、独立表空间、通用表空间、临时表空间和撤销表空间；其他文件有重做日志和双写缓冲区。

表空间：表空间可以理解为`MySQL`为了管理数据而设计的一种数据结构，主要描述结构的定义，表空间文件是对定义的具体实现，以文件的形式存在于磁盘上，以后我们说的表空间指的就是表空间文件。  

![image-20240710175128987](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240710175128987.png)

#### 系统表空间（`System TableSpace`）

系统表空间存储了`MySQL`中所有系统表的数据，也包括数据字典。

系统表空间也是变更缓冲区（`change buffer`）的存储区域，当数据库服务器关闭时，没有合并到缓冲池的二级索引修改操作会被保存到系统表空间。  

#### 独立表空间（`File-Per-Table Tablespace`）

`File-Per-Table` 表空间包含单个`InnoDB`表的数据和索引（`.ibd`文件），默认情况下每张表都对应 一个表空间数据文件，便于维护，所以称为 `File-Per-Table Tablespace`。  

#### 撤销表空间（`Undo Tablespaces`）

撤销表空间中包含撤销日志(`Undo Log`)，撤销日志记录了如何撤销事务对聚集索引记录的最新更改(事务的回滚)，通过对事务的回滚，从而保证事务`ACID`特性中的原子性。  

#### ==Undo Log==（保证事务的原子性）

当事务对数据进行修改的时候，每个修改操作都会在磁盘上创建与之对应的`Undo Log`，当事务需要回滚时，会根据`Undo Log`逐一进行撤销操作，从而保证事务的原子性。也就是说撤销日志是为事务的回滚操作而诞生的机制，它是一个撤销操作记录的集合。  

![image-20240711154259338](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240711154259338.png)

`Undo`链（==以数据行为单位==）：

![image-20240711154426079](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240711154426079.png)

#### 双写缓冲区

双写缓冲区是磁盘上的一个存储区域，当 `InnoDB` 将缓冲池中的数据页写入到磁盘上表空间数据文件之前，先将对应的页写到双写缓冲区（可能有些数据还没有写到双写缓冲区就奔溃了，这时就需要`Redo Log`）；如果在数据真正落盘的过程中出现了意外退出，比如操作系统、存储子系统崩溃或异常断电的情况， `InnoDB` 在崩溃恢复时可以从双写缓冲区中找到一份完好的页副本，执行过程如下图所示：

![image-20240711152544669](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240711152544669.png)  

#### ==Redo Log==（保证事务的持久性）

 重做日志用于在数据库崩溃后恢复==已提交事务还没有来的及落盘==的数据。重做日志以文件的形式保存在磁盘上，在正常的操作过程中，`MySQL`根据受影响的记录进行编码并写入重做日志文件，这些数据称为"`Redo`"，在重新启动时自动读取重做日志进行数据恢复。  

重做日志在保证事务的持久性和一致性方面起到了重要的作用。  

一条`DML`语句的流程：

![image-20240711160620787](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240711160620787.png)

**`MTR(Mini-Transaction)`**是`MySQL`内部对底层数据页的一个原子操作，包含一个`DML`操作产生的一组完整日志，保证数据库异常恢复时数据页中数据的一致性。  

`Mini-Transaction`包含的是一个`DML`操作对应的一组`RedoLog`，而一个事务中可能会包含多个`DML`操作，即一个事务中包含一个或多个`SQL`语句，一个`SQL`语句包含一个或多个`MRT`，一个`MTR`包含一条或多条`RedoLog`，他们之间的关系如下图所示：

![image-20240711195845591](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240711195845591.png)  

**`LSN(Log Sequence Number)`**日志序号。`MySQL`在运行期间，只要执行`DML`操作就会修改数据页，意味着会不断的生成`Redo Log`，`InnoDB`为了记录生成的日志总量(字节数)，设计了一个只增不减的全局变量，这个全局变量就是`LSN`。  

**`checkpoint_lsn`**用于标识磁盘中哪些`Redo Log`已经没有用了：

![image-20240713114402644](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240713114402644.png)

![image-20240713114423719](E:\Note\MySQL\MySQL进阶\InnoDB详解.assets\image-20240713114423719.png)

`CHECKPOINT` 也称为检查点，由于`Redo Log`文件是可以循环使用的，当最后一个文件写满时又会从第一个文件开始写入，这必将导致老的日志被覆盖， `CHECKPOINT` 是标记已被刷新到磁盘的脏页对应的`Redo Log`可以被覆盖的一种操作，当日志的`LSN`小于已落盘脏页对应的`LSN`都可以被覆盖。  

崩溃恢复数据过程：

1. 通过 `checkpoint_lsn` 和第一个没有写满的日志页确定需要恢复日志的起始和结束位置。
2. 遍历日志并把`SpaceId`和`PageNo`相同的日志组织在一起，以便一次性恢复完相应数据页的所有内容。  
3.  日志的`LSN`小于磁盘数据页文件记录的已刷新`LSN`时，表示这些数据在崩溃之前已落盘，跳过即可。  

## 7. 附录（磁盘文件中剩余的两个）

#### 通用表空间（`GeneralTablespace`）

通用表空间是使用 `CREATE tablespace` 语法创建的共享`InnoDB`表空间，一个通用表空间可以存储多个表的数据。（和独立表空间对应---`CREATE table`）   

使用通用表空间就是方便把一些相关的表放到一个通用表空间中，不用每一个表都创建一个独立表空间，一定程度上可以节省空间。（但是增加了表之间的耦合！！所以很少使用）

#### 临时表空间（`Temporary Tablespaces`）

临时表存储的是临时数据，不能永久的存储数据，一般在复杂的查询或计算过程中用来存储过渡的中间结果，`MySQL`在执行查询与计算的过程中会自动生成临时表，比如**表连接查询**时得到的结果集就是一张临时表，因为结果中可能包含多个表中的字段，但是并没有一张真实的表与之完全对应。 

外部临时表：用户自己创建的

内部临时表：系统自动创建的







