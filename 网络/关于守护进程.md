# 关于守护进程

查看进程的属性时可以看到四个ID：PPID（父进程ID），PID（自身ID），PGID（所属组ID），SID（所属的会话ID）

每一个客户端连接服务器都会有一个“会话”的概念，会话中==必须要有且只能有一个前台进程组==，一般都是bash。

而守护进程（精灵进程）就是==让这个进程自成一个新的会话（自成新的进程组），和当前的bash不要有关联==。

### 守护进程的实现

可以使用操作系统提供的系统调用实现：`daemon()`

也可以在运行服务端程序的的时候使用`nohup`命令：`nohup ./test &`

也可以自己定制化实现，必须要用到的系统调用：`setsid()`，让这个进程自己成为一个新的会话。但是组长进程不能调用这个系统调用，所以常用的做法：

```C
if(fork() > 0){
  // 父进程，就是组长进程
  exit(0);
}
// 子进程，这个就不是组长进程了
setsid();
```

一般守护进程编写时需要做的：

1. 忽略`SIGPIPE`信号，当客户端关闭，而服务端还尝试给客户端写数据时服务端会收到`SIGPIPE`信号，进而终止服务端！！这显然不科学。
2. 更改进程的工作目录（选作）
3. `setsid()`  （必做）
4. 因为守护进程就不需要标准输入，标准输出，标准错误了，所以把0，1，2文件描述符重定向到`/dev/null`（`Linux`下的“信息黑洞”，所有写入的数据都被丢弃）（必做）

两个刷新缓冲区的系统调用：

```C
// 把C缓冲区的数据刷新到OS
fflush(out);
// 把OS的缓冲区的数据刷新到磁盘
fsync(fd);
```

