# 网络原理

协议标准文档：`RFC`文档。

### 1. `UDP`

1. 无连接
2. 不可靠传输
3. 面向数据报
4. 全双工

报文结构：

![image-20241204103120216](E:\Note\Java\JavaEE初阶\网络原理.assets\image-20241204103120216.png)

只有16位表示总的报文长度，也就是64KB。

校验和算法：

1. CRC循环冗余校验，简单来说就是把每个字节的只加起来。
2. MD5，定长，分散，不可逆。
3. sha1，和MD5差不多。

### 2. `TCP`

1. 有连接
2. 可靠传输
3. 面向字节流
4. 全双工

报文结构：

![image-20241204103420290](E:\Note\Java\JavaEE初阶\网络原理.assets\image-20241204103420290.png)

**`TCP`保证可靠性的一些手段：**

1. ==确认应答（最核心）==，通过报头中的 序号和确认序号以及`ACK`标记 字段实现。序号表示发送的这个报文数据起始的字节数，确认序号表示接收方下一个应该接收的字节数。
2. 超时重传
3. 连接管理（三次握手，四次挥手）。三次握手作用：验证通信双方的接收和发送是否正常；验证通信网络是否正常；通信双方对一些参数进行协商。四次挥手：先发送`FIN`的一方在 发送完最后一个`ACK`时会进入`TIME_WAIT`状态，主要是为了==确保最后的`ACK`到达对端了==（等待`2*MSL`看对端是否继续发送`FIN`过来，如果发送了就证明`ACK`丢包了！）

![image-20241204155337628](E:\Note\Java\JavaEE初阶\网络原理.assets\image-20241204155337628.png)

**`TCP`提高效率的一些手段：**

1. 滑动窗口。
2. 快重传（滑动窗口情况下的超时重传）。
3. 流量控制（根据对端接收缓冲区剩余空间大小控制发送速率），也就是窗口大小。
4. 拥塞控制（考虑网络拥塞情况，慢启动），也会限制窗口大小。
5. 延迟应答，给点时间让接收端上层读取接收缓冲区中的数据，提高窗口大小。
6. 捎带应答。

#### 粘包问题

字节流形式的数据都会有粘包问题，就是无法区分数据报和数据报之间的边界。这类问题的解决也就是使用各种手段区分边界：

1. 在数据报之间添加分隔符，读到分隔符就代表这个数据报结束。
2. 在数据报的前几个字节记录该报文的长度，读取时先读到长度，再读取对应长度的数据。

### 3. `IP`（地址管理，路由选择）

报文结构：

![image-20241204203010669](E:\Note\Java\JavaEE初阶\网络原理.assets\image-20241204203010669.png)

`IP`地址分为两个部分：网络号（标识局域网）+ 主机号（标识局域网中的主机）

网络号 = `IP` & 子网掩码；剩余的位数就是主机号。

**一些特殊的主机号：**

1. 主机地址全部设为0，就成为了网络号，代表这个局域网。
2. 主机地址全部设为1，就成为了广播地址，用于给同一个局域网中相互连接的所
   有主机发送数据包。  

#### `NAT(Network Address Translation)`技术

`NAT`机制是用来解决`IP`地址不足的问题的。将`IP`地址划分为子网和公网。其中子网：

1.  10.0.0.0-10.255.255.255（10.*）
2.  172.16.0.0-172.31.255.255 （172.16.* - 172.31.*）
3.  192.168.0.0-192.168.255.255 （192.168.*）

这样设备的`IP`地址在局域网内部不重复即可，而不同的局域网之间可以重复。

运营商路由器（`NAT`设备），会对子网的`IP`地址进行替换，替换成公网`IP`，并**使用端口号区分子网的不同主机**（`NAT`设备会记录所有的映射关系），然后在公网中传输。响应回来时`NAT`设备再替换回去，转发到子网内。

`NAT`机制就导致子网设备可以访问公网设备，但是==公网设备无法访问子网设备！！==

### 4. 以太网

1. `MTU`限制了上层的报文长度。
2. 碰撞域（局域网内的传输机制）。

#### `ARP`

`IP`地址转`MAC`地址。

#### `RARP`

`MAC`地址转`IP`地址。













