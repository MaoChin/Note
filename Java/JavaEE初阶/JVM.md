# `JVM`

简单来说，`jvm`虚拟机就是一个运行的`java`程序。

## 1. `jvm`内存区域划分

![image-20240525183627879](E:\Note\Java\JavaEE初阶\JVM.assets\image-20240525183627879.png)

### 1. 方法区/元数据区（多个线程共享）

主要存储类对象（方法）以及静态变量/方法。

### 2. 堆（多个线程共享）

存储`new`的对象

### 3. 栈（每个线程独立）

函数调用栈帧，局部变量。

### 4. 程序计数器（每个线程独立）

就存放一个地址，指向下一条要执行的指令。

## 2. 类加载过程

类加载就是把编译后的 `.class `字节码文件读取到内存中并根据文件内容构造类对象，保存到方法区中。加载过程主要分为5个步骤。

#### 1. 加载文件

找到 `.class` 字节码文件并读取到内存中。

##### 双亲委派模型（查找优先级）

根据 全限定类名（如`java.lang.String`） 找到 `.class` 文件的过程。

`JVM`中的三个类加载器：`BootStrap ClassLoador` 《-  `Extension ClassLoador` 《- `Application ClassLoador`。

1. `BootStrap ClassLoador` ：负责JDK标准库的查找（最先进行）
2. `Extension ClassLoador` ：负责JDK中一些扩展库的查找（其次）
3. `Application ClassLoador`：负责项目当前目录和第三方库目录的查找（最后进行）

#### 2. 验证

验证文件内容是否符合要求。

#### 3. 分配空间

给类对象分配空间。没有初始化

#### 4. 解析

对类对象中的字符串**常量** 等进行初始化（==把“符号引用”替换成“直接引用/地址引用”==）。

在 `.class` 文件中还没有真正的地址，所以对于常量先保存的是 符号引用（一个偏移量），等文件加载并分配地址后再进行替换，替换成真正的地址。

#### 5. 初始化

初始化类对象，包括`static`成员；设置属性等。

## 3. 垃圾回收（`GC`）

`JVM`自动检测申请的内存是还会被使用，并自动释放不再使用的内存/对象。（==针对的是 `new` 出来的堆上的内存/对象==）

缺陷：

1. 系统开销大。需要额外的线程不断检测内存。
2. 效率低！！
3. 释放内存不及时。有可能同一时刻出现大量内存需要被回收，`GC`负担突然增大造成整个程序卡顿（STW 问题）。

### 1. 找到要释放的内存/对象

##### 1. 引用计数（Python，PHP）

当一个对象 没有引用指向 时就可以认为是垃圾了。

缺点：

1. 浪费内存，每个对象都要有额外的内存存储计数器。
2. 循环引用问题！！！（类似死锁）导致错误判断垃圾，使得垃圾不能被回收。

##### 2. 可达性分析 （Java）

本质上是 时间换取空间 的做法。

周期性的从一些对象出发，尽可能的访问其牵连出的所有对象（多叉树），并标记这些可以访问的对象（“可达”），而后那些没有被标记为“可达”的对象就会被释放。

分析的出发点称为 `GCRoots` 。

### 2. 回收垃圾

一些基本思路：

##### 1. 标记清除（很挫）

直接把上述找到的垃圾释放掉。会产生内存碎片！！！

##### 2. 复制算法

就是把有效的对象统一复制到另一块大内存中（连续），然后把原来的 垃圾+有效的对象 都释放掉。可以避免内存碎片，但是拷贝开销很大，且内存利用率低。

##### 3. 标记整理

简单来说就是把有效内存/对象进行规整，直接覆盖掉垃圾。可以提高内存利用率，但是依旧有拷贝开销。

##### 4. 分代回收

结合了上述机制进行分代（新生代，老年代）。







