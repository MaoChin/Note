# 计算机概述

## 1. 冯诺伊曼体系结构

![image-20241122212011989](E:\Note\Java\JavaEE初阶\计算机概述.assets\image-20241122212011989.png)

CPU = ALU + CU + 寄存器 + 时钟 + ......

==衡量CPU：核心数+主频==

## 2. 进程初识

管理的本质：描述+组织

==进程是向操作系统申请资源的基本单位。==如`CPU`资源，内存资源，磁盘资源，网卡资源等等。

进程对应的描述结构：`PCB(process control block)`，在`Linux`中是`task_struct`这个结构体。

进程之间具有：==独立性==，竞争性.....

### 2.1 `PCB`中的一些关键数据：

1. `pid`：标识一个进程。
2. **一组**内存指针：标识占有哪些内存，如存放进程指令，数据和运行时产生的临时数据等。
3. 文件描述符表：存放所有的文件描述符。
4. `CPU`调度相关数据：进程状态，优先级，上下文数据（保存现场，回复现场），记账信息等。

#### 2.1.1 进程状态

1. 运行态：进程真正`CPU`上运行。
2. 就绪态：进程在就绪队列中等待，随时可以运行。
3. 阻塞态：进程在等待其他资源，比如内存，磁盘，键盘等资源；无法在`CPU`上运行。
4. 僵尸态（`Linux`特有）：进程退出后会进入僵尸态，等待父进程回收其资源。

#### 2.1.2 上下文数据（一般在寄存器中）

下述信息一般在`CPU`的寄存器中，在进程被切走的时候需要把这些信息保存到内存中，当进程切回来的时候再从内存中加载。

1. 当前进程执行到了哪一条指令（程序计数器，`pc`指针）
2. 当前进程的调用堆栈相关信息
3. 进程运行过程中产生的临时数据

#### 2.1.3 记账信息

简单来说就是进程记录一段时间内再`CPU`上执行的总时长，用于动态调整优先级等，作为进程调度的一个参考。（防止饥饿的情况）

### 2.2 进程间通信

通信的本质就是让多个进程可以访问到一块公共的空间！完成数据的交互。

常见的进程间通信方式：

1. 管道（命名管道，匿名管道）
2. 共享内存
3. 文件
4. 网络（`socket`）
5. 信号量
6. 信号 （`signal`）

## 3. 虚拟地址空间

对物理内存进行的抽象封装。优点：

1. **扩充内存**！虚拟地址空间可能远远大于实际物理内存。通过懒加载，内存页换入换处等一系列机制使得进程无法感知。
2. **保护物理内存**。用户无法直接访问物理内存，在页表映射时，通过页表的权限检查防止用户的非法操作。 
3. 将进程管理和内存管理进行解耦。站在进程的角度，所有的虚拟地址空间分布都是一样的。也保证了进程的独立性。

## 4. 理解并发和并行

并发：在一个核心上运行大量的进程/线程，通过切换调度轮流执行，轮流向前推进。

并行：在同一时刻，两个或多个核心上分别独立的运行两个或多个进程/线程，同时向前推荐，这两个或多个进程/线程就是并行的。

## 5. 线程初识

线程也可以叫做“轻量级进程”。进程内包含线程。

==线程是`CPU`调度执行的基本单位。==也就是说，`CPU`实际执行是以线程为基本单位的。

一个进程内可以包含多个线程，但是至少要有一个线程，称为“主线程”。多个线程之间共享进程的内存空间，文件描述符表等资源，但是`CPU`调度相关数据每一个线程都有一份。

一个进程内的多个线程可能会引发的问题：

1. 线程安全问题
2. 其中一个线程出现问题，抛出异常，如果没有妥善处理，那么整个进程可能就直接终止了。

### 5.1 前台线程和后台线程/守护线程

前台线程会影响到整个进程是否结束，只有进程中所有的前台线程都结束了，进程才有可能结束；而后台线程对进程是否结束不造成不影响。

## 6. 进程和线程的区别

1. 进程内包含线程。一个进程内的多个线程共享进程的内存空间和文件描述符表等资源。
2. 进程和线程都可以用来进行并发编程，但是线程更轻量（不需要申请销毁资源，调度切换保存的上下文数据也更少）。
3. **进程间具有独立性，但是线程之间会相互影响**（线程安全问题，线程异常可能会影响其他线程甚至整个进程）。
4. 进程是向操作系统申请资源的基本单位。线程是`CPU`调度执行的基本单位。

## 7. 协程

进程-》线程-》协程。

线程是轻量级进程，协程可以理解为轻量级线程！

线程省去了 创建销毁 申请释放资源的开销，协程省去了调度的开销！
