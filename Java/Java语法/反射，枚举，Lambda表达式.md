# 反射，枚举，Lambda表达式

## 1. 反射

反射（`reflection`）机制是在**运行**状态中，对于任意一个类，都能够知道这个类的**所有属性和方法**；对于任意一个对象，都能够调用它的任意方法和属性，既然能拿到，我们就可以修改部分类型信息；这种动态获取信息以及动态调用对象方法的功能称为`java`语言的反射（`reflection`）机制。  

反射相关的类：

| 类名            | 用途                                             |
| --------------- | ------------------------------------------------ |
| `Class`类       | 代表类的实体，在运行的Java应用程序中表示类和接口 |
| `Field`类       | 代表类的成员变量/类的属性                        |
| `Method`类      | 代表类的方法                                     |
| `Constructor`类 | 代表类的构造方法                                 |

## 2. 枚举

和C++的枚举差不多。

```java
public enum TestEnum {
	RED,BLACK,GREEN;
}
```

我们自己写的枚举类，就算没有显示的继承 `Enum`，也会默认继承这个类，且==其构造方法默认为私有的==。  

`Enum`类的常用方法：

| 方法名称      | 描述                             |
| ------------- | -------------------------------- |
| `values`()    | 以数组形式返回枚举类型的所有成员 |
| `ordinal`()   | 获取枚举成员的索引位置           |
| `valueOf`()   | 将普通字符串转换为枚举实例       |
| `compareTo`() | 比较两个枚举成员在定义时的顺序   |

枚举可以避免反射和序列化问题。也就是说，无法通过反射机制创建枚举类！

## 3. `Lambda`表达式

函数式接口：一个接口有且只有一个抽象方法。 `Lambda`表达式更多的是简化 函数式接口 的使用。也可以说是简化 匿名内部类 的使用。

基本格式：`(parameters) -> expression` 或 `(parameters) ->{ statements; }  `

变量捕获：`java`中的`lambda`表达式可以自动捕获上一层作用域的局部变量，但是只能捕获常量（`final`修饰）或者初始化后没有再被修改的变量！！



